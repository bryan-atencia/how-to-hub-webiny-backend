{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nimport * as React from 'react';\nimport { MDCSliderFoundation } from '@material/slider';\nimport { componentFactory, FoundationComponent, debounce } from '@rmwc/base';\nvar SliderRoot = componentFactory({\n  displayName: 'SliderRoot',\n  classNames: function (props) {\n    return ['mdc-slider', {\n      'mdc-slider--discrete': props.discrete,\n      'mdc-slider--display-markers': props.displayMarkers && props.discrete\n    }];\n  },\n  consumeProps: ['discrete', 'displayMarkers']\n});\n\nvar SliderTrack =\n/** @class */\nfunction (_super) {\n  __extends(SliderTrack, _super);\n\n  function SliderTrack() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SliderTrack.prototype.shouldComponentUpdate = function () {\n    return false;\n  };\n\n  SliderTrack.prototype.render = function () {\n    return React.createElement(\"div\", {\n      ref: this.props.elementRef,\n      className: \"mdc-slider__track\"\n    });\n  };\n\n  SliderTrack.displayName = 'SliderTrack';\n  return SliderTrack;\n}(React.Component);\n\nvar SliderTrackMarkerContainer =\n/** @class */\nfunction (_super) {\n  __extends(SliderTrackMarkerContainer, _super);\n\n  function SliderTrackMarkerContainer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SliderTrackMarkerContainer.prototype.render = function () {\n    return React.createElement(\"div\", {\n      className: \"mdc-slider__track-marker-container\"\n    }, __spread(Array(this.props.markersCount)).map(function (v, i) {\n      return React.createElement(\"div\", {\n        className: \"mdc-slider__track-marker\",\n        key: i\n      });\n    }));\n  };\n\n  SliderTrackMarkerContainer.displayName = 'SliderTrackMarkerContainer';\n  return SliderTrackMarkerContainer;\n}(React.PureComponent);\n\nvar SliderPin =\n/** @class */\nfunction (_super) {\n  __extends(SliderPin, _super);\n\n  function SliderPin() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SliderPin.prototype.render = function () {\n    var value = this.props.value;\n    return React.createElement(\"div\", {\n      className: \"mdc-slider__pin\"\n    }, React.createElement(\"span\", {\n      className: \"mdc-slider__pin-value-marker\"\n    }, value));\n  };\n\n  SliderPin.displayName = 'SliderPin';\n  return SliderPin;\n}(React.PureComponent);\n\nvar SliderThumb =\n/** @class */\nfunction (_super) {\n  __extends(SliderThumb, _super);\n\n  function SliderThumb() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SliderThumb.prototype.shouldComponentUpdate = function () {\n    return false;\n  };\n\n  SliderThumb.prototype.render = function () {\n    return React.createElement(\"svg\", {\n      className: \"mdc-slider__thumb\",\n      width: \"21\",\n      height: \"21\"\n    }, React.createElement(\"circle\", {\n      cx: \"10.5\",\n      cy: \"10.5\",\n      r: \"7.875\"\n    }));\n  };\n\n  SliderThumb.displayName = 'SliderThumb';\n  return SliderThumb;\n}(React.Component);\n\nvar SliderFocusRing =\n/** @class */\nfunction (_super) {\n  __extends(SliderFocusRing, _super);\n\n  function SliderFocusRing() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SliderFocusRing.prototype.shouldComponentUpdate = function () {\n    return false;\n  };\n\n  SliderFocusRing.prototype.render = function () {\n    return React.createElement(\"div\", {\n      className: \"mdc-slider__focus-ring\"\n    });\n  };\n\n  SliderFocusRing.displayName = 'SliderFocusRing';\n  return SliderFocusRing;\n}(React.Component);\n/** A Slider component. */\n\n\nvar Slider =\n/** @class */\nfunction (_super) {\n  __extends(Slider, _super);\n\n  function Slider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      trackMarkersCount: 0,\n      pinContainerStyle: {}\n    };\n    _this.root = _this.createElement('root');\n    _this.thumbContainer = _this.createElement('thumbContainer');\n    _this.sliderPin = _this.createElement('sliderPin');\n    _this.track = null;\n    return _this;\n  }\n\n  Slider.prototype.componentDidMount = function () {\n    _super.prototype.componentDidMount.call(this); // Fixes an issue where synthetic events were being\n    // accessed in the Foundation and causing an error\n\n\n    var existinghandleDown_ = this.foundation.handleDown_.bind(this.foundation);\n\n    this.foundation.handleDown_ = function (evt) {\n      evt.persist();\n      existinghandleDown_(evt);\n    };\n  };\n\n  Object.defineProperty(Slider.prototype, \"value\", {\n    /** @return {number} */\n    get: function () {\n      return this.foundation.getValue();\n    },\n\n    /** @param {number} value */\n    set: function (value) {\n      // make value in bounds\n      if (value < this.min) {\n        console.warn(\"Attempted to set slider to \" + value + \" which is less than min: \" + this.min);\n        value = this.min;\n      }\n\n      if (value > this.max) {\n        console.warn(\"Attempted to set slider to \" + value + \" which is greater than max: \" + this.max);\n        value = this.max;\n      }\n\n      this.foundation.setValue(value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slider.prototype, \"min\", {\n    /** @return {number} */\n    get: function () {\n      return this.foundation.getMin();\n    },\n\n    /** @param {number} min */\n    set: function (min) {\n      this.foundation.setMin(min);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slider.prototype, \"max\", {\n    /** @return {number} */\n    get: function () {\n      return this.foundation.getMax();\n    },\n\n    /** @param {number} max */\n    set: function (max) {\n      this.foundation.setMax(max);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slider.prototype, \"step\", {\n    /** @return {number} */\n    get: function () {\n      return this.foundation.getStep();\n    },\n\n    /** @param {number} step */\n    set: function (step) {\n      this.foundation.setStep(step);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slider.prototype, \"disabled\", {\n    /** @return {boolean} */\n    get: function () {\n      return this.foundation.isDisabled();\n    },\n\n    /** @param {boolean} disabled */\n    set: function (disabled) {\n      this.foundation.setDisabled(disabled);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slider.prototype, \"discrete\", {\n    get: function () {\n      return !!(this.foundation && this.foundation.isDiscrete_);\n    },\n    set: function (isDiscrete) {\n      if (this.foundation) {\n        this.foundation.isDiscrete_ = isDiscrete;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slider.prototype, \"displayMarkers\", {\n    get: function () {\n      return !!this.foundation && this.foundation.hasTrackMarker_;\n    },\n    set: function (isDisplayMarkers) {\n      if (this.foundation) {\n        this.foundation.hasTrackMarker_ = isDisplayMarkers;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Slider.prototype.layout = function () {\n    this.foundation.layout();\n  };\n\n  Slider.prototype.sync = function (props, prevProps) {\n    var _this = this; // max\n\n\n    if (props.max !== undefined && props.max !== this.max) {\n      this.max = props.max !== undefined ? +props.max : this.max;\n    } // min\n\n\n    if (props.min !== undefined && props.min !== this.min) {\n      this.min = props.min !== undefined ? +props.min : this.min;\n    } // value\n\n\n    if (props.value !== undefined && props.value !== this.value) {\n      this.value = props.value !== undefined ? Number(props.value) : this.value;\n    } // step\n\n\n    if (props.step !== undefined && props.step !== this.step) {\n      this.step = props.step !== undefined ? +props.step : this.step;\n    } // disabled\n\n\n    if (props.disabled !== undefined && props.disabled !== this.disabled) {\n      this.disabled = !!props.disabled;\n    } // discrete\n\n\n    if (props.discrete !== undefined && props.discrete !== this.discrete) {\n      this.discrete = !!props.discrete;\n    } //eslint-disable-next-line eqeqeq\n\n\n    if (this.discrete && this.foundation && this.foundation.getStep() == 0) {\n      this.step = 1;\n    } // displayMarkers\n\n\n    if (props.displayMarkers !== undefined && props.displayMarkers !== this.displayMarkers) {\n      this.displayMarkers = !!props.displayMarkers;\n      window.requestAnimationFrame(function () {\n        return _this.foundation && _this.foundation.setupTrackMarker();\n      });\n    }\n  };\n\n  Slider.prototype.getDefaultFoundation = function () {\n    var _this = this;\n\n    return new MDCSliderFoundation({\n      hasClass: function (className) {\n        return _this.root.hasClass(className);\n      },\n      addClass: function (className) {\n        return _this.root.addClass(className);\n      },\n      removeClass: function (className) {\n        return _this.root.removeClass(className);\n      },\n      getAttribute: function (name) {\n        return _this.root.getProp(name);\n      },\n      setAttribute: debounce(function (name, value) {\n        return _this.root.setProp(name, value);\n      }, 300),\n      removeAttribute: function (name) {\n        return _this.root.removeProp(name);\n      },\n      computeBoundingRect: function () {\n        return _this.root.ref ? _this.root.ref.getBoundingClientRect() : {};\n      },\n      getTabIndex: function () {\n        return _this.root.ref ? _this.root.ref.tabIndex : 0;\n      },\n      registerInteractionHandler: function (evtType, handler) {\n        _this.root.addEventListener(evtType, handler);\n      },\n      deregisterInteractionHandler: function (evtType, handler) {\n        _this.root.removeEventListener(evtType, handler);\n      },\n      registerThumbContainerInteractionHandler: function (evtType, handler) {\n        _this.thumbContainer.addEventListener(evtType, handler);\n      },\n      deregisterThumbContainerInteractionHandler: function (evtType, handler) {\n        _this.thumbContainer.removeEventListener(evtType, handler);\n      },\n      registerBodyInteractionHandler: function (evtType, handler) {\n        document.body && document.body.addEventListener(evtType, handler);\n      },\n      deregisterBodyInteractionHandler: function (evtType, handler) {\n        document.body && document.body.removeEventListener(evtType, handler);\n      },\n      registerResizeHandler: function (handler) {\n        window.addEventListener('resize', handler);\n      },\n      deregisterResizeHandler: function (handler) {\n        window.removeEventListener('resize', handler);\n      },\n      notifyInput: function () {\n        _this.emit('onInput', {\n          value: _this.value\n        });\n      },\n      notifyChange: function () {\n        _this.emit('onChange', {\n          value: _this.value\n        });\n      },\n      setThumbContainerStyleProperty: function (propertyName, value) {\n        _this.thumbContainer.setStyle(propertyName, value);\n      },\n      setTrackStyleProperty: function (propertyName, value) {\n        _this.track && _this.track.style.setProperty(propertyName, value);\n      },\n      setMarkerValue: function (value) {\n        _this.sliderPin.setProp('value', value);\n      },\n      appendTrackMarkers: function (numMarkers) {\n        _this.setState({\n          trackMarkersCount: numMarkers\n        });\n      },\n      removeTrackMarkers: function () {\n        _this.setState({\n          trackMarkersCount: 0\n        });\n      },\n      setLastTrackMarkersStyleProperty: function (propertyName, value) {\n        if (_this.root.ref) {\n          // We remove and append new nodes, thus, the last track marker must be dynamically found.\n          var lastTrackMarker = _this.root.ref.querySelector(MDCSliderFoundation.strings.LAST_TRACK_MARKER_SELECTOR);\n\n          lastTrackMarker && lastTrackMarker.style.setProperty(propertyName, value);\n        }\n      },\n      isRTL: function () {\n        return !!_this.root.ref && getComputedStyle(_this.root.ref).direction === 'rtl';\n      }\n    });\n  };\n\n  Slider.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        value = _a.value,\n        min = _a.min,\n        max = _a.max,\n        discrete = _a.discrete,\n        displayMarkers = _a.displayMarkers,\n        step = _a.step,\n        disabled = _a.disabled,\n        onChange = _a.onChange,\n        onInput = _a.onInput,\n        children = _a.children,\n        rest = __rest(_a, [\"value\", \"min\", \"max\", \"discrete\", \"displayMarkers\", \"step\", \"disabled\", \"onChange\", \"onInput\", \"children\"]);\n\n    var dataStep = step ? {\n      'data-step': step\n    } : {};\n    var tsxValue = value;\n    var tsxMax = max;\n\n    if (displayMarkers && !discrete) {\n      console.warn(\"The 'displayMarkers' prop on rmwc Slider will\\n        only work in conjunction with the 'discrete' prop\");\n    }\n\n    return React.createElement(SliderRoot, __assign({\n      tabIndex: 0,\n      //eslint-disable-next-line jsx-a11y/role-has-required-aria-props\n      role: \"slider\",\n      \"aria-valuemax\": tsxMax,\n      \"aria-valuenow\": tsxValue,\n      \"aria-label\": \"Select Value\",\n      ref: this.root.setRef,\n      discrete: discrete,\n      displayMarkers: displayMarkers\n    }, disabled ? {\n      'aria-disabled': disabled\n    } : {}, dataStep, this.root.props(rest)), React.createElement(\"div\", {\n      className: \"mdc-slider__track-container\"\n    }, React.createElement(SliderTrack, {\n      elementRef: function (ref) {\n        return _this.track = ref;\n      }\n    }), displayMarkers && React.createElement(SliderTrackMarkerContainer, {\n      markersCount: this.state.trackMarkersCount\n    })), React.createElement(\"div\", __assign({}, this.thumbContainer.props({\n      className: 'mdc-slider__thumb-container'\n    })), discrete && React.createElement(SliderPin, __assign({}, this.sliderPin.props({}))), React.createElement(SliderThumb, null), React.createElement(SliderFocusRing, null)), children);\n  };\n\n  Slider.displayName = 'Slider';\n  return Slider;\n}(FoundationComponent);\n\nexport { Slider };","map":null,"metadata":{},"sourceType":"module"}