{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _trim2 = _interopRequireDefault(require(\"lodash/trim\"));\n\nvar _isEmpty2 = _interopRequireDefault(require(\"lodash/isEmpty\"));\n\nvar _isString2 = _interopRequireDefault(require(\"lodash/isString\"));\n\nvar _validationError = _interopRequireDefault(require(\"./validationError\"));\n\nconst entries = validators => {\n  return Object.entries(validators);\n};\n\nconst invalidRules = \"Validators must be specified as a string (eg. required,minLength:10,email).\";\nconst createdValidators = {\n  async: {},\n  sync: {}\n};\n/**\n * Main class of Validation library.\n * Exported as a singleton instance, it offers methods for sync/async data validation and overwriting or adding new validators.\n *\n * @class Validation\n * @example\n * import { validation } from '@webiny/validation';\n *\n * // `validation` is a preconfigured instance of Validation class.\n * // From here you can either add new validators or use it as-is.\n */\n\nclass Validation {\n  /**\n   * Contains a list of all set validators.\n   * @private\n   */\n  constructor() {\n    (0, _defineProperty2.default)(this, \"__validators\", void 0);\n    this.__validators = {};\n  }\n  /**\n   * Add new validator.\n   * @param name Validator name.\n   * @param callable Validator function which throws a ValidationError if validation fails.\n   * @returns {Validation}\n   */\n\n\n  setValidator(name, callable) {\n    this.__validators[name] = callable;\n    return this;\n  }\n  /**\n   * Get validator function by name.\n   * @param name Validator name.\n   * @returns {Validator} A validator function.\n   */\n\n\n  getValidator(name) {\n    if (!this.__validators[name]) {\n      throw new _validationError.default(\"Validator `\" + name + \"` does not exist!\", name);\n    }\n\n    return this.__validators[name];\n  }\n  /**\n   * Asynchronously validates value.\n   * @param value Value to validate.\n   * @param validators A list of comma-separated validators (eg. required,number,gt:20).\n   * @param [options] Validation options.\n   * @returns {Promise<boolean | ValidationError>}\n   */\n\n\n  async validate(value, validators, options = {}) {\n    if ((0, _isString2.default)(validators) && (0, _isEmpty2.default)(validators)) {\n      return true;\n    }\n\n    if (!(0, _isString2.default)(validators)) {\n      throw new Error(invalidRules);\n    }\n\n    const parsedValidateProperty = this.__parseValidateProperty(validators);\n\n    for (const [name, params] of entries(parsedValidateProperty)) {\n      const validator = this.getValidator(name);\n\n      try {\n        await validator(value, params);\n      } catch (e) {\n        const validationError = new _validationError.default(e.message, name, value);\n\n        if (options.throw === false) {\n          return validationError;\n        }\n\n        throw validationError;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Synchronously validates value.\n   * @param value Value to validate.\n   * @param validators A list of comma-separated validators (eg. required,number,gt:20).\n   * @param [options] Validation options.\n   * @returns {Promise<boolean | ValidationError>}\n   */\n\n\n  validateSync(value, validators, options = {}) {\n    if ((0, _isString2.default)(validators) && (0, _isEmpty2.default)(validators)) {\n      return true;\n    }\n\n    if (!(0, _isString2.default)(validators)) {\n      throw new Error(invalidRules);\n    }\n\n    const parsedValidateProperty = this.__parseValidateProperty(validators);\n\n    for (const [name, params] of entries(parsedValidateProperty)) {\n      const validator = this.getValidator(name);\n\n      try {\n        validator(value, params);\n      } catch (e) {\n        const validationError = new _validationError.default(e.message, name, value);\n\n        if (options.throw === false) {\n          return validationError;\n        }\n\n        throw validationError;\n      }\n    }\n\n    return true;\n  }\n\n  create(validators) {\n    if (createdValidators.async[validators]) {\n      return createdValidators.async[validators];\n    }\n\n    createdValidators.async[validators] = value => this.validate(value, validators);\n\n    return createdValidators.async[validators];\n  }\n\n  createSync(validators) {\n    if (createdValidators.sync[validators]) {\n      return createdValidators.sync[validators];\n    }\n\n    createdValidators.sync[validators] = value => this.validateSync(value, validators);\n\n    return createdValidators.sync[validators];\n  }\n  /**\n   * Parses a string of validators with parameters.\n   * @param validators A list of comma-separated validators (eg. required,number,gt:20).\n   * @returns {ParsedValidators}\n   * @private\n   */\n\n\n  __parseValidateProperty(validators) {\n    const validate = validators.split(\",\");\n    const parsedValidators = {};\n    validate.forEach(v => {\n      const params = (0, _trim2.default)(v).split(\":\");\n      const vName = params.shift();\n      parsedValidators[vName] = params;\n    });\n    return parsedValidators;\n  }\n\n}\n\nvar _default = Validation;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}