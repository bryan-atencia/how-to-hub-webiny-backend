{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport { withProviderContext } from '@rmwc/provider';\nimport { componentFactory, classNames, deprecationWarning } from '@rmwc/base';\n/**\n * Given content, tries to figure out an appropriate strategy for it\n */\n\nvar processAutoStrategy = function (content) {\n  // check for URLS\n  if (typeof content === 'string' && content.includes('/')) {\n    return 'url';\n  } // handle JSX components\n\n\n  if (React.isValidElement(content)) {\n    return 'component';\n  } // we dont know what it is, default to ligature for compat with material icons\n\n\n  return 'ligature';\n};\n/**\n * Get the actual icon strategy to use\n */\n\n\nexport var getIconStrategy = function (content, strategy, providerStrategy) {\n  strategy = strategy || providerStrategy || 'auto';\n\n  if (strategy === 'auto') {\n    return processAutoStrategy(content);\n  }\n\n  return strategy;\n};\n\nvar renderLigature = function (_a) {\n  var content = _a.content,\n      rest = __rest(_a, [\"content\"]);\n\n  return React.createElement(IconRoot, __assign({}, rest), content);\n};\n\nvar renderClassName = function (_a) {\n  var content = _a.content,\n      rest = __rest(_a, [\"content\"]);\n\n  return React.createElement(IconRoot, __assign({}, rest));\n};\n\nvar renderUrl = function (_a) {\n  var content = _a.content,\n      rest = __rest(_a, [\"content\"]);\n\n  return React.createElement(IconRoot, __assign({}, rest, {\n    className: classNames(rest.className, 'rmwc-icon--image'),\n    style: __assign({}, rest.style, {\n      backgroundImage: \"url(\" + content + \")\"\n    })\n  }));\n};\n\nvar renderComponent = function (_a) {\n  var content = _a.content,\n      rest = __rest(_a, [\"content\"]);\n\n  if (content.type === 'svg') {\n    var _b = content.props,\n        children = _b.children,\n        svgRest = __rest(_b, [\"children\"]);\n\n    return React.createElement(IconRoot, __assign({}, svgRest, rest, {\n      tag: \"svg\"\n    }), children);\n  }\n\n  return React.createElement(IconRoot, __assign({}, rest), content);\n};\n\nvar iconRenderMap = {\n  ligature: renderLigature,\n  className: renderClassName,\n  url: renderUrl,\n  component: renderComponent,\n  auto: undefined\n};\n\nvar buildIconOptions = function (icon) {\n  if (React.isValidElement(icon) || icon && typeof icon !== 'object') {\n    return {\n      icon: icon\n    };\n  }\n\n  return icon;\n};\n\nvar IconRoot = componentFactory({\n  displayName: 'IconRoot',\n  tag: 'i'\n});\n/** An Icon component. Most of these options can be set once globally, read the documentation on Provider for more info. */\n\nexport var Icon = withProviderContext()(function (_a) {\n  var _b;\n\n  var icon = _a.icon,\n      deprecatedIconOption = _a.iconOptions,\n      providerContext = _a.providerContext,\n      rest = __rest(_a, [\"icon\", \"iconOptions\", \"providerContext\"]); // handle deprecation\n\n\n  if (!!deprecatedIconOption) {\n    var converted = __assign({\n      content: typeof icon === 'string' ? icon : \"<MyComponent {...}/>\"\n    }, deprecatedIconOption);\n\n    deprecationWarning(\"Icon component prop 'iconOptions' is deprecated. You options should now be passed directly to the 'icon' prop. I.E. icon={\" + JSON.stringify(converted) + \"}\");\n  } // Build icon options object\n\n\n  var _c = __assign({}, buildIconOptions(icon), deprecatedIconOption),\n      content = _c.icon,\n      strategy = _c.strategy,\n      prefix = _c.prefix,\n      basename = _c.basename,\n      render = _c.render,\n      size = _c.size,\n      optionsRest = __rest(_c, [\"icon\", \"strategy\", \"prefix\", \"basename\", \"render\", \"size\"]); // Get provider options\n\n\n  var _d = providerContext.icon || {},\n      _e = _d.basename,\n      providerBasename = _e === void 0 ? null : _e,\n      _f = _d.prefix,\n      providerPrefix = _f === void 0 ? null : _f,\n      _g = _d.strategy,\n      providerStrategy = _g === void 0 ? null : _g,\n      _h = _d.render,\n      providerRender = _h === void 0 ? null : _h;\n\n  var contentToUse = content;\n  var strategyToUse = getIconStrategy(contentToUse, strategy || null, providerStrategy || null);\n  var prefixToUse = prefix || providerPrefix;\n  var basenameToUse = basename === undefined ? providerBasename : basename;\n  var iconClassName = strategyToUse === 'className' && typeof content === 'string' ? \"\" + String(prefixToUse) + content : null;\n  var rendererFromMap = !!strategyToUse && iconRenderMap[strategyToUse]; // For some reason TS thinks the render method will return undefined...\n\n  var renderToUse = strategyToUse === 'custom' ? render || providerRender : rendererFromMap || null;\n\n  if (!renderToUse) {\n    console.error(\"Icon: rendering not implemented for \" + String(strategyToUse) + \".\");\n    return null;\n  }\n\n  var rendered = renderToUse(__assign({}, rest, optionsRest, {\n    content: contentToUse,\n    className: classNames('rmwc-icon', basenameToUse, rest.className, optionsRest.className, iconClassName, (_b = {}, _b[\"rmwc-icon--size-\" + (size || '')] = !!size, _b))\n  })); // Unwrap double layered icons...\n\n  if (rendered.props.children && rendered.props.children.type && ['Avatar', 'Icon'].includes(rendered.props.children.type.displayName)) {\n    return React.cloneElement(rendered.props.children, __assign({}, rendered.props.children.props, rendered.props, {\n      // prevents an infinite loop\n      children: rendered.props.children.props.children,\n      className: classNames(rendered.props.className, rendered.props.children.props.className)\n    }));\n  }\n\n  return rendered;\n});\nIcon.displayName = 'Icon';","map":null,"metadata":{},"sourceType":"module"}