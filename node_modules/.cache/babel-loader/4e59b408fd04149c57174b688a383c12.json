{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport * as React from \"react\";\nimport BrowseFiles from \"react-butterfiles\";\nimport { css } from \"emotion\";\nimport classNames from \"classnames\";\nimport { FormElementMessage } from \"@webiny/ui/FormElementMessage\";\nimport Image from \"./Image\";\nimport ImageEditorDialog from \"./ImageEditorDialog\";\nvar imagesStyle = /*#__PURE__*/css({\n  \".disabled\": {\n    opacity: 0.75,\n    pointerEvents: \"none\"\n  },\n  \"ul.images\": {\n    listStyle: \"none\",\n    li: {\n      verticalAlign: \"top\",\n      margin: 2,\n      display: \"inline-block\",\n      width: 150,\n      height: 150,\n      \"&:last-child\": {\n        border: \"1px solid lightgray\",\n        cursor: \"pointer\",\n        textAlign: \"center\"\n      }\n    }\n  }\n}, \"label:imagesStyle;\"); // Do not apply editping for following image types.\n// const noImageEditorTypes = [\"image/svg+xml\", \"image/gif\"];\n\nvar MultiImageUpload = /*#__PURE__*/function (_React$Component) {\n  _inherits(MultiImageUpload, _React$Component);\n\n  var _super = _createSuper(MultiImageUpload);\n\n  function MultiImageUpload() {\n    var _this;\n\n    _classCallCheck(this, MultiImageUpload);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      errors: null,\n      selectedImages: {},\n      loading: false,\n      imageEditor: {\n        open: false,\n        image: null,\n        index: null\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onChange\", /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n        var _this$props, onChange, validate;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$props = _this.props, onChange = _this$props.onChange, validate = _this$props.validate;\n                _context.t0 = onChange;\n\n                if (!_context.t0) {\n                  _context.next = 5;\n                  break;\n                }\n\n                _context.next = 5;\n                return onChange(value);\n\n              case 5:\n                _context.t1 = validate;\n\n                if (!_context.t1) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 9;\n                return validate();\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this), \"handleSelectedImages\", /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(images) {\n        var selectedIndex,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                selectedIndex = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 0;\n\n                _this.setState({\n                  errors: null,\n                  loading: true\n                }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                  var selectedImages, i, image;\n                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          selectedImages = {};\n\n                          for (i = 0; i < images.length; i++) {\n                            image = images[i];\n                            selectedImages[selectedIndex + i] = _objectSpread({}, image);\n                          }\n\n                          _this.setState({\n                            selectedImages: selectedImages\n                          }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                            var newValue, convertedImages, _i, _image;\n\n                            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                              while (1) {\n                                switch (_context2.prev = _context2.next) {\n                                  case 0:\n                                    newValue = Array.isArray(_this.props.value) ? _toConsumableArray(_this.props.value) : [];\n                                    convertedImages = [];\n\n                                    for (_i = 0; _i < images.length; _i++) {\n                                      _image = images[_i];\n                                      convertedImages.push({\n                                        src: _image.src.base64,\n                                        name: _image.name,\n                                        size: _image.size,\n                                        type: _image.type\n                                      });\n                                    }\n\n                                    newValue.splice.apply(newValue, [selectedIndex, 0].concat(convertedImages));\n                                    _context2.next = 6;\n                                    return _this.onChange(newValue);\n\n                                  case 6:\n                                    _this.setState({\n                                      loading: false\n                                    });\n\n                                  case 7:\n                                  case \"end\":\n                                    return _context2.stop();\n                                }\n                              }\n                            }, _callee2);\n                          })));\n\n                        case 3:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                })));\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(_assertThisInitialized(_this), \"handleErrors\", function (errors) {\n      _this.setState({\n        errors: errors\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"removeImage\", function (image) {\n      var _this$props2 = _this.props,\n          value = _this$props2.value,\n          onChange = _this$props2.onChange;\n\n      if (!onChange) {\n        return;\n      }\n\n      var images = Array.isArray(value) ? _toConsumableArray(value) : [];\n      images.splice(images.indexOf(image), 1);\n      onChange(images);\n    });\n\n    return _this;\n  }\n\n  _createClass(MultiImageUpload, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props3 = this.props,\n          value = _this$props3.value,\n          validation = _this$props3.validation,\n          label = _this$props3.label,\n          description = _this$props3.description,\n          disabled = _this$props3.disabled,\n          imageEditor = _this$props3.imageEditor,\n          accept = _this$props3.accept,\n          maxSize = _this$props3.maxSize,\n          className = _this$props3.className;\n      var imageEditorImageSrc = \"\";\n\n      if (this.state.imageEditor.image) {\n        imageEditorImageSrc = this.state.imageEditor.image.src;\n      }\n\n      return /*#__PURE__*/React.createElement(\"div\", {\n        className: classNames(imagesStyle, className)\n      }, label && /*#__PURE__*/React.createElement(\"div\", {\n        className: \"mdc-floating-label mdc-floating-label--float-above\"\n      }, label), /*#__PURE__*/React.createElement(ImageEditorDialog, {\n        options: imageEditor,\n        open: this.state.imageEditor.open,\n        src: imageEditorImageSrc,\n        onClose: function onClose() {\n          _this2.setState(function (state) {\n            state.imageEditor.open = false;\n            return state;\n          });\n        },\n        onAccept: function onAccept(src) {\n          // We wrapped everything into setTimeout - prevents dialog freeze when larger image is selected.\n          setTimeout(function () {\n            _this2.setState({\n              loading: true\n            }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n              var newValue, imageEditorImageIndex;\n              return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                while (1) {\n                  switch (_context5.prev = _context5.next) {\n                    case 0:\n                      newValue = Array.isArray(_this2.props.value) ? _toConsumableArray(_this2.props.value) : [];\n                      imageEditorImageIndex = _this2.state.imageEditor.index;\n                      newValue[imageEditorImageIndex].src = src;\n                      _context5.next = 5;\n                      return _this2.onChange(newValue);\n\n                    case 5:\n                      _this2.setState({\n                        loading: false,\n                        imageEditor: {\n                          image: null,\n                          open: false,\n                          index: null\n                        }\n                      });\n\n                    case 6:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }\n              }, _callee5);\n            })));\n          });\n        }\n      }), /*#__PURE__*/React.createElement(BrowseFiles, {\n        accept: accept,\n        maxSize: maxSize,\n        multiple: true,\n        convertToBase64: true,\n        onSuccess: function onSuccess(files) {\n          _this2.handleSelectedImages(files, Array.isArray(value) ? value.length : 0);\n        },\n        onError: function onError(errors) {\n          return _this2.handleErrors(errors);\n        }\n      }, function (_ref6) {\n        var browseFiles = _ref6.browseFiles,\n            getDropZoneProps = _ref6.getDropZoneProps;\n        var images = Array.isArray(value) ? _toConsumableArray(value) : [];\n        return /*#__PURE__*/React.createElement(\"div\", getDropZoneProps({\n          className: classNames({\n            disabled: disabled\n          })\n        }), /*#__PURE__*/React.createElement(\"ul\", {\n          className: \"images\"\n        }, images.map(function (image, index) {\n          return /*#__PURE__*/React.createElement(\"li\", {\n            key: index\n          }, /*#__PURE__*/React.createElement(Image, {\n            loading: _this2.state.selectedImages[index] && _this2.state.loading,\n            value: image.file || image,\n            removeImage: function removeImage() {\n              return _this2.removeImage(image.file || image);\n            },\n            editImage: _this2.state.selectedImages[index] && function () {\n              _this2.setState({\n                imageEditor: {\n                  index: index,\n                  open: true,\n                  image: _this2.state.selectedImages[index]\n                }\n              });\n            },\n            uploadImage: function uploadImage() {\n              browseFiles({\n                onSuccess: function onSuccess(files) {\n                  _this2.handleSelectedImages(files, index + 1);\n                },\n                onError: function onError(errors) {\n                  return _this2.handleErrors(errors);\n                }\n              });\n            }\n          }));\n        }), /*#__PURE__*/React.createElement(\"li\", null, /*#__PURE__*/React.createElement(Image, {\n          disabled: _this2.state.loading,\n          uploadImage: function uploadImage() {\n            browseFiles({\n              onSuccess: function onSuccess(files) {\n                _this2.handleSelectedImages(files, Array.isArray(value) ? value.length : 0);\n              },\n              onError: function onError(errors) {\n                return _this2.handleErrors(errors);\n              }\n            });\n          }\n        }))));\n      }), validation.isValid === false && /*#__PURE__*/React.createElement(FormElementMessage, {\n        error: true\n      }, validation.message), validation.isValid !== false && description && /*#__PURE__*/React.createElement(FormElementMessage, null, description), Array.isArray(this.state.errors) && /*#__PURE__*/React.createElement(FormElementMessage, {\n        error: true\n      }, \"Your selection of images failed because of the following images:\", /*#__PURE__*/React.createElement(\"ul\", null, this.state.errors.map(function (error, index) {\n        return /*#__PURE__*/React.createElement(\"li\", {\n          key: error.file.name + index\n        }, index + 1, \". \", /*#__PURE__*/React.createElement(\"strong\", null, error.file.name), \" -\\xA0\", _this2.props.errorMessages[error.type] || _this2.props.errorMessages.default);\n      }))));\n    }\n  }]);\n\n  return MultiImageUpload;\n}(React.Component);\n\n_defineProperty(MultiImageUpload, \"defaultProps\", {\n  validation: {\n    isValid: null\n  },\n  accept: [\"image/jpeg\", \"image/png\", \"image/gif\", \"image/svg+xml\"],\n  maxSize: \"5mb\",\n  imageEditor: {},\n  errorMessages: {\n    maxSizeExceeded: \"Max size exceeded.\",\n    unsupportedFileType: \"Unsupported file type.\",\n    default: \"An error occurred.\"\n  }\n});\n\nexport { MultiImageUpload };","map":null,"metadata":{},"sourceType":"module"}