{"ast":null,"code":"// parseActions helper: takes a string (or array)\n//                      and makes it an array if it isn't yet\nexport function parseActions(rawActions) {\n  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (Array.isArray(rawActions)) {\n    return rawActions;\n  } else if (typeof rawActions === \"string\") {\n    return [rawActions];\n  }\n\n  return defaultValue;\n} // isHistory helper: check for a valid history object\n\nexport function isHistory(history) {\n  return typeof history.present !== \"undefined\" && typeof history.future !== \"undefined\" && typeof history.past !== \"undefined\" && Array.isArray(history.future) && Array.isArray(history.past);\n} // distinctState helper: deprecated, does nothing in latest beta\n\n/* istanbul ignore next */\n\nexport function distinctState() {\n  console.warn(\"distinctState is deprecated in beta4 and newer. \" + \"The distinctState behavior is now default, which means only \" + \"actions resulting in a new state are recorded. \" + \"See https://github.com/omnidan/redux-undo#filtering-actions \" + \"for more details.\");\n  return function () {\n    return true;\n  };\n} // includeAction helper: whitelist actions to be added to the history\n\nexport function includeAction(rawActions) {\n  var actions = parseActions(rawActions);\n  return function (action) {\n    return actions.indexOf(action.type) >= 0;\n  };\n} // excludeAction helper: blacklist actions from being added to the history\n\nexport function excludeAction(rawActions) {\n  var actions = parseActions(rawActions);\n  return function (action) {\n    return actions.indexOf(action.type) < 0;\n  };\n} // combineFilters helper: combine multiple filters to one\n\nexport function combineFilters() {\n  for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {\n    filters[_key] = arguments[_key];\n  }\n\n  return filters.reduce(function (prev, curr) {\n    return function (action, currentState, previousHistory) {\n      return prev(action, currentState, previousHistory) && curr(action, currentState, previousHistory);\n    };\n  }, function () {\n    return true;\n  });\n}\nexport function groupByActionTypes(rawActions) {\n  var actions = parseActions(rawActions);\n  return function (action) {\n    return actions.indexOf(action.type) >= 0 ? action.type : null;\n  };\n}\nexport function newHistory(past, present, future) {\n  var group = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return {\n    past: past,\n    present: present,\n    future: future,\n    group: group,\n    _latestUnfiltered: present,\n    index: past.length,\n    limit: past.length + future.length + 1\n  };\n}","map":null,"metadata":{},"sourceType":"module"}