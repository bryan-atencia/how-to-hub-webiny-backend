{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\"; // @ts-nocheck\n\nimport * as debug from \"./debug\";\nimport { ActionTypes } from \"./actions\";\nimport { parseActions, isHistory, newHistory } from \"./helpers\"; // createHistory\n\nfunction createHistory(state, ignoreInitialState) {\n  // ignoreInitialState essentially prevents the user from undoing to the\n  // beginning, in the case that the undoable reducer handles initialization\n  // in a way that can't be redone simply\n  var history = newHistory([], state, []);\n\n  if (ignoreInitialState) {\n    history._latestUnfiltered = null;\n  }\n\n  return history;\n} // lengthWithoutFuture: get length of history\n\n\nfunction lengthWithoutFuture(history) {\n  return history.past.length + 1;\n} // insert: insert `state` into history, which means adding the current state\n//         into `past`, setting the new `state` as `present` and erasing\n//         the `future`.\n\n\nfunction insert(history, state, limit, group) {\n  debug.log(\"inserting\", state);\n  debug.log(\"new free: \", limit - lengthWithoutFuture(history));\n  var past = history.past,\n      _latestUnfiltered = history._latestUnfiltered;\n  var historyOverflow = limit && lengthWithoutFuture(history) >= limit;\n  var pastSliced = past.slice(historyOverflow ? 1 : 0);\n  var newPast = _latestUnfiltered != null ? [].concat(_toConsumableArray(pastSliced), [_latestUnfiltered]) : pastSliced;\n  return newHistory(newPast, state, [], group);\n} // jumpToFuture: jump to requested index in future history\n\n\nfunction jumpToFuture(history, index) {\n  if (index < 0 || index >= history.future.length) {\n    return history;\n  }\n\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPast = [].concat(_toConsumableArray(past), [_latestUnfiltered], _toConsumableArray(future.slice(0, index)));\n  var newPresent = future[index];\n  var newFuture = future.slice(index + 1);\n  return newHistory(newPast, newPresent, newFuture);\n} // jumpToPast: jump to requested index in past history\n\n\nfunction jumpToPast(history, index) {\n  if (index < 0 || index >= history.past.length) {\n    return history;\n  }\n\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPast = past.slice(0, index);\n  var newFuture = [].concat(_toConsumableArray(past.slice(index + 1)), [_latestUnfiltered], _toConsumableArray(future));\n  var newPresent = past[index];\n  return newHistory(newPast, newPresent, newFuture);\n} // jump: jump n steps in the past or forward\n\n\nfunction jump(history, n) {\n  if (n > 0) {\n    return jumpToFuture(history, n - 1);\n  }\n\n  if (n < 0) {\n    return jumpToPast(history, history.past.length + n);\n  }\n\n  return history;\n} // helper to dynamically match in the reducer's switch-case\n\n\nfunction actionTypeAmongClearHistoryType(actionType, clearHistoryType) {\n  return clearHistoryType.indexOf(actionType) > -1 ? actionType : !actionType;\n} // redux-undo higher order reducer\n\n\nexport default function undoable(reducer) {\n  var rawConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  debug.set(rawConfig.debug);\n  var config = {\n    initTypes: parseActions(rawConfig.initTypes, [\"@@redux-undo/INIT\"]),\n    limit: rawConfig.limit,\n    filter: rawConfig.filter || function () {\n      return true;\n    },\n    groupBy: rawConfig.groupBy || function () {\n      return null;\n    },\n    undoType: rawConfig.undoType || ActionTypes.UNDO,\n    redoType: rawConfig.redoType || ActionTypes.REDO,\n    jumpToPastType: rawConfig.jumpToPastType || ActionTypes.JUMP_TO_PAST,\n    jumpToFutureType: rawConfig.jumpToFutureType || ActionTypes.JUMP_TO_FUTURE,\n    jumpType: rawConfig.jumpType || ActionTypes.JUMP,\n    clearHistoryType: Array.isArray(rawConfig.clearHistoryType) ? rawConfig.clearHistoryType : [rawConfig.clearHistoryType || ActionTypes.CLEAR_HISTORY],\n    neverSkipReducer: rawConfig.neverSkipReducer || false,\n    ignoreInitialState: rawConfig.ignoreInitialState || false,\n    syncFilter: rawConfig.syncFilter || false\n  };\n  var initialState = config.history;\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n    var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var _len = arguments.length, slices = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      slices[_key - 2] = arguments[_key];\n    }\n\n    debug.start(action, state);\n    var history = state;\n\n    if (!initialState) {\n      debug.log(\"history is uninitialized\");\n\n      if (state === undefined) {\n        var clearHistoryAction = {\n          type: ActionTypes.CLEAR_HISTORY\n        };\n        var start = reducer.apply(void 0, [state, clearHistoryAction].concat(slices));\n        history = createHistory(start, config.ignoreInitialState);\n        debug.log(\"do not set initialState on probe actions\");\n      } else if (isHistory(state)) {\n        history = initialState = config.ignoreInitialState ? state : newHistory(state.past, state.present, state.future);\n        debug.log(\"initialHistory initialized: initialState is a history\", initialState);\n      } else {\n        history = initialState = createHistory(state, config.ignoreInitialState);\n        debug.log(\"initialHistory initialized: initialState is not a history\", initialState);\n      }\n    }\n\n    var skipReducer = function skipReducer(res) {\n      return config.neverSkipReducer ? _objectSpread(_objectSpread({}, res), {}, {\n        present: reducer.apply(void 0, [res.present, action].concat(slices))\n      }) : res;\n    };\n\n    var res;\n\n    switch (action.type) {\n      case undefined:\n        return history;\n\n      case config.undoType:\n        res = jump(history, -1);\n        debug.log(\"perform undo\");\n        debug.end(res);\n        return skipReducer(res);\n\n      case config.redoType:\n        res = jump(history, 1);\n        debug.log(\"perform redo\");\n        debug.end(res);\n        return skipReducer(res);\n\n      case config.jumpToPastType:\n        res = jumpToPast(history, action.index);\n        debug.log(\"perform jumpToPast to \".concat(action.index));\n        debug.end(res);\n        return skipReducer(res);\n\n      case config.jumpToFutureType:\n        res = jumpToFuture(history, action.index);\n        debug.log(\"perform jumpToFuture to \".concat(action.index));\n        debug.end(res);\n        return skipReducer(res);\n\n      case config.jumpType:\n        res = jump(history, action.index);\n        debug.log(\"perform jump to \".concat(action.index));\n        debug.end(res);\n        return skipReducer(res);\n\n      case actionTypeAmongClearHistoryType(action.type, config.clearHistoryType):\n        res = createHistory(history.present, config.ignoreInitialState);\n        debug.log(\"perform clearHistory\");\n        debug.end(res);\n        return skipReducer(res);\n\n      default:\n        res = reducer.apply(void 0, [history.present, action].concat(slices));\n\n        if (config.initTypes.some(function (actionType) {\n          return actionType === action.type;\n        })) {\n          debug.log(\"reset history due to init action\");\n          debug.end(initialState);\n          history = initialState = createHistory(state, config.ignoreInitialState);\n          return initialState;\n        }\n\n        if (history._latestUnfiltered === res) {\n          // Don't handle this action. Do not call debug.end here,\n          // because this action should not produce side effects to the console\n          return history;\n        }\n\n        var filtered = typeof config.filter === \"function\" && !config.filter(action, res, history);\n\n        if (filtered) {\n          // if filtering an action, merely update the present\n          var filteredState = newHistory(history.past, res, history.future, history.group);\n\n          if (!config.syncFilter) {\n            filteredState._latestUnfiltered = history._latestUnfiltered;\n          }\n\n          debug.log(\"filter ignored action, not storing it in past\");\n          debug.end(filteredState);\n          return filteredState;\n        }\n\n        var group = config.groupBy(action, res, history);\n\n        if (group != null && group === history.group) {\n          // if grouping with the previous action, only update the present\n          var groupedState = newHistory(history.past, res, history.future, history.group);\n          debug.log(\"groupBy grouped the action with the previous action\");\n          debug.end(groupedState);\n          return groupedState;\n        } // If the action wasn't filtered or grouped, insert normally\n\n\n        history = insert(history, res, config.limit, group);\n        debug.log(\"inserted new state into history\");\n        debug.end(history);\n        return history;\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}