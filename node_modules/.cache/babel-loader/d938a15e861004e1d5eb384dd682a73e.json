{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport { MDCSnackbarFoundation, util } from '@material/snackbar';\nimport { Button } from '@rmwc/button';\nimport { componentFactory, FoundationComponent, handleDeprecations, closest } from '@rmwc/base';\nimport { IconButton } from '@rmwc/icon-button';\nimport { Icon } from '@rmwc/icon';\n/** Monkey patch the foundation to accept dynamic reasons rather than just \"action\" */\n// @ts-ignore\n\nMDCSnackbarFoundation.prototype.handleActionButtonClick = function (evt, reason) {\n  this.close(reason);\n};\n\nvar SnackbarRoot = componentFactory({\n  displayName: 'SnackbarRoot',\n  classNames: function (props) {\n    return ['mdc-snackbar', {\n      'mdc-snackbar--leading': props.leading,\n      'mdc-snackbar--stacked': props.stacked\n    }];\n  },\n  defaultProps: {\n    leading: false,\n    'aria-live': 'assertive',\n    'aria-atomic': true,\n    'aria-hidden': true\n  },\n  consumeProps: ['leading', 'stacked']\n});\nvar SnackbarLabel = componentFactory({\n  displayName: 'SnackbarText',\n  classNames: ['mdc-snackbar__label'],\n  defaultProps: {\n    role: 'status',\n    'aria-live': 'polite'\n  }\n});\nvar SnackbarActions = componentFactory({\n  displayName: 'SnackbarActions',\n  classNames: ['mdc-snackbar__actions']\n});\n/** A button for a snackbar action. */\n\nexport var SnackbarAction = componentFactory({\n  displayName: 'SnackbarAction',\n  tag: Button,\n  classNames: ['mdc-snackbar__action'],\n  render: function (_a, ref, Tag) {\n    var _b = _a.action,\n        action = _b === void 0 ? MDCSnackbarFoundation.strings.REASON_ACTION : _b,\n        rest = __rest(_a, [\"action\"]);\n\n    return React.createElement(Tag, __assign({}, rest, {\n      ref: ref,\n      \"data-mdc-snackbar-action\": action\n    }));\n  }\n});\nvar SnackbarDismiss = componentFactory({\n  displayName: 'SnackbarDismiss',\n  tag: IconButton,\n  classNames: ['mdc-snackbar__dismiss']\n});\n/** A Snackbar component for notifications. */\n\nvar Snackbar =\n/** @class */\nfunction (_super) {\n  __extends(Snackbar, _super);\n\n  function Snackbar(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.root = _this.createElement('root');\n    _this.isShowing_ = false;\n    _this.labelEl = null;\n    _this.announce = util.announce;\n    _this.handleKeyDown = _this.handleKeyDown.bind(_this);\n    _this.handleSurfaceClick = _this.handleSurfaceClick.bind(_this);\n    return _this;\n  }\n\n  Snackbar.prototype.getDefaultFoundation = function () {\n    var _this = this;\n    /* eslint brace-style: \"off\" */\n\n\n    return new MDCSnackbarFoundation({\n      addClass: function (className) {\n        return _this.root.addClass(className);\n      },\n      removeClass: function (className) {\n        return _this.root.removeClass(className);\n      },\n      announce: function () {\n        return _this.labelEl && _this.announce(_this.labelEl);\n      },\n      notifyOpening: function () {\n        return _this.emit('onOpen', {});\n      },\n      notifyOpened: function () {\n        return _this.emit('onOpened', {});\n      },\n      notifyClosing: function (reason) {\n        return _this.emit('onClose', reason ? {\n          reason: reason\n        } : {});\n      },\n      notifyClosed: function (reason) {\n        return _this.emit('onClosed', reason ? {\n          reason: reason\n        } : {});\n      }\n    });\n  };\n\n  Snackbar.prototype.sync = function (props, prevProps) {\n    props = this.getPropsWithDeprecations(props);\n    prevProps = this.getPropsWithDeprecations(prevProps); // open\n\n    if (props.open !== prevProps.open && props.open) {\n      this.foundation.open();\n    } // timeout\n\n\n    if (props.timeout !== prevProps.timeout) {\n      // dont tell me what I can cant set my timeout too...\n      // directly patch over using setTimeoutMs\n      this.foundation.autoDismissTimeoutMs_ = props.timeout;\n    }\n  };\n\n  Snackbar.prototype.getPropsWithDeprecations = function (props) {\n    return handleDeprecations(props, {\n      show: 'open',\n      onShow: 'onOpen',\n      onHide: 'onClose',\n      alignStart: 'leading',\n      multiline: '',\n      actionOnBottom: 'stacked',\n      actionHandler: '',\n      actionText: ''\n    }, 'Snackbar');\n  };\n\n  Snackbar.prototype.handleKeyDown = function (evt) {\n    this.props.onKeyDown && this.props.onKeyDown(evt);\n    this.foundation.handleKeyDown(evt);\n  };\n\n  Snackbar.prototype.handleSurfaceClick = function (evt) {\n    if (evt.target instanceof Element) {\n      var el = evt.target;\n      var button = closest(el, '.mdc-button');\n\n      if (button) {\n        el = button;\n      }\n\n      if (this.props.dismissesOnAction && el.classList.contains('mdc-snackbar__action')) {\n        this.foundation.handleActionButtonClick(evt, // @ts-ignore\n        el.dataset.mdcSnackbarAction);\n      } else if (el.classList.contains('mdc-snackbar__dismiss')) {\n        this.foundation.handleActionIconClick(evt);\n      }\n    }\n  };\n\n  Snackbar.prototype.render = function () {\n    var _this = this; // grab these before we try to correct them in the deprecation\n\n\n    var _a = this.props,\n        actionText = _a.actionText,\n        actionHandler = _a.actionHandler;\n\n    var _b = this.getPropsWithDeprecations(this.props),\n        open = _b.open,\n        message = _b.message,\n        timeout = _b.timeout,\n        dismissIcon = _b.dismissIcon,\n        onOpen = _b.onOpen,\n        onClose = _b.onClose,\n        children = _b.children,\n        action = _b.action,\n        icon = _b.icon,\n        dismissesOnAction = _b.dismissesOnAction,\n        rest = __rest(_b, [\"open\", \"message\", \"timeout\", \"dismissIcon\", \"onOpen\", \"onClose\", \"children\", \"action\", \"icon\", \"dismissesOnAction\"]);\n\n    var actions = Array.isArray(action) ? action : action ? [action] : [];\n    return React.createElement(SnackbarRoot, __assign({}, this.root.props(rest), {\n      ref: this.root.setRef,\n      onKeyDown: this.handleKeyDown\n    }), React.createElement(\"div\", {\n      className: \"mdc-snackbar__surface\",\n      onClick: this.handleSurfaceClick\n    }, !!icon && React.createElement(Icon, {\n      style: {\n        color: 'rgba(255, 255, 255, 0.87)',\n        fill: 'currentColor',\n        marginLeft: '1rem'\n      },\n      icon: icon\n    }), React.createElement(SnackbarLabel, null, message, React.createElement(\"div\", {\n      style: {\n        display: 'none'\n      },\n      ref: function (el) {\n        return _this.labelEl = el;\n      }\n    })), React.createElement(SnackbarActions, null, !!actionText && React.createElement(SnackbarAction, {\n      onClick: actionHandler\n    }, actionText), actions.map(function (a, i) {\n      return React.createElement(React.Fragment, {\n        key: i\n      }, a);\n    }), dismissIcon && React.createElement(SnackbarDismiss, {\n      icon: dismissIcon === true ? 'close' : dismissIcon\n    })), children));\n  };\n\n  Snackbar.displayName = 'Snackbar';\n  Snackbar.defaultProps = {\n    dismissesOnAction: true\n  };\n  return Snackbar;\n}(FoundationComponent);\n\nexport { Snackbar };","map":null,"metadata":{},"sourceType":"module"}