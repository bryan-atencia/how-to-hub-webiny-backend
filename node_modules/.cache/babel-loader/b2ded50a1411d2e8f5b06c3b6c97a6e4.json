{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport { MDCMenuFoundation } from '@material/menu';\nimport { List, ListItem } from '@rmwc/list';\nimport { componentFactory, FoundationComponent, closest } from '@rmwc/base';\nimport { MenuSurface, MenuSurfaceAnchor } from './menu-surface';\n/** A wrapper for menu items */\n\nexport var MenuItems = componentFactory({\n  displayName: 'MenuItems',\n  tag: List,\n  classNames: ['mdc-list mdc-menu__items'],\n  defaultProps: {\n    role: 'menu'\n  }\n});\n/** This is just the ListItem component exported from the Menu module for convenience. You can use `ListItem` or `SimpleListItem` components from the List section as long as you add `role=\"menuitem\"` and `tabIndex=\"0\"` to the components for accessibility. */\n\nexport var MenuItem = componentFactory({\n  displayName: 'MenuItem',\n  tag: ListItem,\n  defaultProps: {\n    role: 'menuitem',\n    tabIndex: 0\n  }\n});\n\nvar isMenuItems = function isMenuItems(child) {\n  return React.isValidElement(child) && typeof child.type === 'object' && ('displayName' in child.type && child.type.displayName) === 'MenuItems';\n};\n/** A menu component for displaying lists items. */\n\n\nvar Menu =\n/** @class */\nfunction (_super) {\n  __extends(Menu, _super);\n\n  function Menu(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.list = null;\n    _this.menuSurface = null;\n    _this.handleKeydown = _this.handleKeydown.bind(_this);\n    _this.handleClick = _this.handleClick.bind(_this);\n    _this.handleOpen = _this.handleOpen.bind(_this);\n    return _this;\n  }\n\n  Object.defineProperty(Menu.prototype, \"items\", {\n    get: function get() {\n      return this.list ? this.list.listElements : [];\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Menu.prototype.hoistMenuToBody = function () {\n    this.menuSurface && this.menuSurface.hoistMenuToBody();\n  };\n\n  Menu.prototype.setAnchorCorner = function (corner) {\n    this.menuSurface && this.menuSurface.setAnchorCorner(corner);\n  };\n\n  Menu.prototype.setAnchorElement = function (element) {\n    this.menuSurface && (this.menuSurface.anchorElement = element);\n  };\n\n  Menu.prototype.getDefaultFoundation = function () {\n    var _this = this;\n\n    return new MDCMenuFoundation({\n      addClassToElementAtIndex: function addClassToElementAtIndex(index, className) {\n        var list = _this.items;\n        list[index].classList.add(className);\n      },\n      removeClassFromElementAtIndex: function removeClassFromElementAtIndex(index, className) {\n        var list = _this.items;\n        list[index].classList.remove(className);\n      },\n      addAttributeToElementAtIndex: function addAttributeToElementAtIndex(index, attr, value) {\n        var list = _this.items;\n        list[index].setAttribute(attr, value);\n      },\n      removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex(index, attr) {\n        var list = _this.items;\n        list[index].removeAttribute(attr);\n      },\n      elementContainsClass: function elementContainsClass(element, className) {\n        return element.classList.contains(className);\n      },\n      closeSurface: function closeSurface() {\n        _this.menuSurface && (_this.menuSurface.open = false);\n      },\n      getElementIndex: function getElementIndex(element) {\n        return _this.items.indexOf(element);\n      },\n      notifySelected: function notifySelected(evtData) {\n        return _this.emit('onSelect', {\n          index: evtData.index,\n          item: _this.items[evtData.index]\n        });\n      },\n      getMenuItemCount: function getMenuItemCount() {\n        return _this.items.length;\n      },\n      focusItemAtIndex: function focusItemAtIndex(index) {\n        return _this.items[index].focus();\n      },\n      focusListRoot: function focusListRoot() {\n        return _this.list && _this.list.root && _this.list.root.ref && _this.list.root.ref.focus();\n      }\n    });\n  };\n\n  Menu.prototype.handleClick = function (evt) {\n    this.props.onClick && this.props.onClick(evt); // fixes an issue with nested span element on list items\n\n    var el = closest(evt.target, '.mdc-list-item');\n    el && this.foundation.handleItemAction(el);\n  };\n\n  Menu.prototype.handleKeydown = function (evt) {\n    this.props.onKeyDown && this.props.onKeyDown(evt);\n    this.foundation.handleKeydown(evt); // Jump through some hoops to find out\n    // that we are selecting the list item\n    // This is instead of trying to listen to an event on the list item\n    // which is what MDC does\n\n    if (evt.which === 13 && evt.target instanceof Element && evt.target.classList.contains(List.cssClasses.LIST_ITEM_CLASS)) {\n      this.foundation.handleItemAction(evt.target);\n    }\n  };\n\n  Menu.prototype.handleOpen = function (evt) {\n    var list = this.items;\n\n    if (this.props.focusOnOpen && list.length > 0 && !list.some(function (el) {\n      return el === document.activeElement;\n    })) {\n      list[0].focus();\n    }\n\n    this.props.onOpen && this.props.onOpen(evt);\n  };\n\n  Menu.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        children = _a.children,\n        focusOnOpen = _a.focusOnOpen,\n        rest = __rest(_a, [\"children\", \"focusOnOpen\"]);\n\n    var needsMenuItemsWrapper = (React.Children.map(children, isMenuItems) || []).every(function (val) {\n      return val === false;\n    });\n    return React.createElement(MenuSurface, __assign({}, rest, {\n      \"aria-hidden\": !rest.open,\n      className: \"mdc-menu \" + (rest.className || ''),\n      onKeyDown: this.handleKeydown,\n      onClick: this.handleClick,\n      onOpen: this.handleOpen,\n      ref: function ref(menuSurfaceApi) {\n        return _this.menuSurface = menuSurfaceApi;\n      }\n    }), needsMenuItemsWrapper ? React.createElement(MenuItems, {\n      ref: function ref(listApi) {\n        return _this.list = listApi;\n      }\n    }, children) : React.Children.map(children, function (child) {\n      if (isMenuItems(child)) {\n        return React.cloneElement(child, {\n          ref: function ref(listApi) {\n            return _this.list = listApi;\n          }\n        });\n      }\n\n      return child;\n    }));\n  };\n\n  Menu.displayName = 'Menu';\n  Menu.defaultProps = {\n    focusOnOpen: true\n  };\n  return Menu;\n}(FoundationComponent);\n\nexport { Menu };\n\nvar simpleMenuFactory = function simpleMenuFactory(MenuComponent) {\n  var _a;\n\n  return _a =\n  /** @class */\n  function (_super) {\n    __extends(class_1, _super);\n\n    function class_1() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.state = {\n        open: !!_this.props.open\n      };\n      return _this;\n    }\n\n    class_1.prototype.componentDidMount = function () {\n      this.syncWithOpenProp(this.props.open);\n    };\n\n    class_1.prototype.componentDidUpdate = function (nextProps) {\n      this.syncWithOpenProp(nextProps.open);\n    };\n\n    class_1.prototype.syncWithOpenProp = function (open) {\n      if (open !== undefined && this.state.open !== open) {\n        this.setState({\n          open: open\n        });\n      }\n    };\n\n    class_1.prototype.render = function () {\n      var _this = this;\n\n      var _a = this.props,\n          handle = _a.handle,\n          onClose = _a.onClose,\n          children = _a.children,\n          _b = _a.rootProps,\n          rootProps = _b === void 0 ? {} : _b,\n          open = _a.open,\n          rest = __rest(_a, [\"handle\", \"onClose\", \"children\", \"rootProps\", \"open\"]);\n\n      var wrappedHandle = React.cloneElement(handle, __assign({}, handle.props, {\n        onClick: function onClick(evt) {\n          _this.setState({\n            open: !_this.state.open\n          });\n\n          if (handle.props.onClick) {\n            handle.props.onClick(evt);\n          }\n        }\n      }));\n\n      var wrappedOnClose = function wrappedOnClose(evt) {\n        _this.setState({\n          open: !!open || false\n        });\n\n        if (onClose) {\n          onClose(evt);\n        }\n      };\n\n      return React.createElement(MenuSurfaceAnchor, __assign({}, rootProps), React.createElement(MenuComponent, __assign({}, rest, {\n        onClose: wrappedOnClose,\n        open: this.state.open\n      }), children), wrappedHandle);\n    };\n\n    return class_1;\n  }(React.Component), _a.displayName = 'Simple' + MenuComponent.displayName, _a;\n};\n/** A Simplified menu component that allows you to pass a handle element and will automatically control the open state and add a MenuSurfaceAnchor */\n\n\nexport var SimpleMenu = simpleMenuFactory(Menu);\n/** The same as SimpleMenu, but a generic surface. */\n\nexport var SimpleMenuSurface = simpleMenuFactory(MenuSurface);","map":null,"metadata":{},"sourceType":"module"}