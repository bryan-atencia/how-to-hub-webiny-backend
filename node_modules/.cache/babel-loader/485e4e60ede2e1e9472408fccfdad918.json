{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _assign2 = _interopRequireDefault(require(\"lodash/assign\"));\n\nvar _get2 = _interopRequireDefault(require(\"lodash/get\"));\n\nvar _shortHash = _interopRequireDefault(require(\"short-hash\"));\n\nvar fecha = _interopRequireWildcard(require(\"fecha\"));\n\nvar _accounting = _interopRequireDefault(require(\"accounting\"));\n/**\n * Main class used for all I18n needs.\n */\n\n\nclass I18N {\n  constructor() {\n    (0, _defineProperty2.default)(this, \"locale\", void 0);\n    (0, _defineProperty2.default)(this, \"defaultFormats\", void 0);\n    (0, _defineProperty2.default)(this, \"translations\", void 0);\n    (0, _defineProperty2.default)(this, \"modifiers\", void 0);\n    (0, _defineProperty2.default)(this, \"processors\", void 0);\n    this.locale = null;\n    /**\n     * If we fail to fetch formats for currently selected locale, these default formats will be used.\n     * @type {{date: string, time: string, datetime: string, number: string}}\n     */\n\n    this.defaultFormats = this.getDefaultFormats();\n    /**\n     * All currently-loaded translations, for easier (synchronous) access.\n     * @type {{}}\n     */\n\n    this.translations = {};\n    /**\n     * All registered modifiers.\n     * @type {{}}\n     */\n\n    this.modifiers = {};\n    /**\n     * All registered processors.\n     * Default built-in processors are registered immediately below.\n     * @type {{}}\n     */\n\n    this.processors = {};\n  }\n\n  translate(base, namespace) {\n    // Returns full translation for given base text in given namespace (optional).\n    // If translation isn't found, base text will be returned.\n    // We create a key out of given namespace and base text.\n    if (!namespace) {\n      throw Error(\"I18N text namespace not defined.\");\n    }\n\n    base = (0, _get2.default)(base, \"raw.0\", base);\n    let translation = this.getTranslation(namespace + \".\" + (0, _shortHash.default)(base));\n\n    if (!translation) {\n      translation = base;\n    }\n\n    const hasVariables = base.includes(\"{\") && base.includes(\"}\");\n\n    if (hasVariables) {\n      // @ts-ignore\n      return values => {\n        const data = {\n          translation,\n          base,\n          namespace,\n          values,\n          i18n: this\n        };\n\n        for (const key in this.processors) {\n          if (this.processors[key].canExecute(data)) {\n            return this.processors[key].execute(data);\n          }\n        }\n\n        return null;\n      };\n    }\n\n    const data = {\n      translation,\n      base,\n      namespace,\n      values: {},\n      i18n: this\n    };\n\n    for (const key in this.processors) {\n      if (this.processors[key].canExecute(data)) {\n        return this.processors[key].execute(data);\n      }\n    }\n\n    return null;\n  }\n\n  namespace(namespace) {\n    return base => {\n      return this.translate(base, namespace);\n    };\n  }\n\n  ns(namespace) {\n    return this.namespace(namespace);\n  }\n  /**\n   * Formats and outputs date.\n   * It will try to load format from currently selected locale's settings. If not defined, default formats will be used.\n   * @param value\n   * @param outputFormat\n   * @param inputFormat\n   */\n\n\n  date(value, outputFormat, inputFormat) {\n    if (!outputFormat) {\n      outputFormat = this.getDateFormat();\n    }\n\n    let parsedValue;\n\n    if (typeof value === \"string\") {\n      parsedValue = fecha.parse(value, inputFormat);\n    }\n\n    return fecha.format(parsedValue, outputFormat);\n  }\n  /**\n   * Formats and outputs time.\n   * It will try to load format from currently selected locale's settings. If not defined, default formats will be used.\n   * @param value\n   * @param outputFormat\n   * @param inputFormat\n   */\n\n\n  time(value, outputFormat = null, inputFormat = \"YYYY-MM-DDTHH:mm:ss.SSSZ\") {\n    if (!outputFormat) {\n      outputFormat = this.getTimeFormat();\n    }\n\n    let parsedValue;\n\n    if (typeof value === \"string\") {\n      parsedValue = fecha.parse(value, inputFormat);\n    }\n\n    return fecha.format(parsedValue, outputFormat);\n  }\n  /**\n   * Formats and outputs date/time.\n   * It will try to load format from currently selected locale's settings. If not defined, default formats will be used.\n   * @param value\n   * @param outputFormat\n   * @param inputFormat\n   */\n\n\n  dateTime(value, outputFormat = null, inputFormat = \"YYYY-MM-DDTHH:mm:ss.SSSZ\") {\n    if (!outputFormat) {\n      outputFormat = this.getDateTimeFormat();\n    }\n\n    let parsedValue;\n\n    if (typeof value === \"string\") {\n      parsedValue = fecha.parse(value, inputFormat);\n    }\n\n    return fecha.format(parsedValue, outputFormat);\n  }\n  /**\n   * Outputs formatted number as amount of price.\n   * @param value\n   * @param outputFormat\n   */\n\n\n  price(value, outputFormat) {\n    if (!outputFormat) {\n      outputFormat = this.getPriceFormat();\n    } else {\n      outputFormat = (0, _assign2.default)({}, this.defaultFormats.price, outputFormat);\n    } // Convert placeholders to accounting's placeholders.\n\n\n    let format = outputFormat.format;\n    format = format.replace(\"{symbol}\", \"%s\");\n    format = format.replace(\"{amount}\", \"%v\");\n    return _accounting.default.formatMoney(value, outputFormat.symbol, outputFormat.precision, outputFormat.thousand, outputFormat.decimal, format);\n  }\n  /**\n   * Outputs formatted number.\n   * @param value\n   * @param outputFormat\n   */\n\n\n  number(value, outputFormat) {\n    if (!outputFormat) {\n      outputFormat = this.getNumberFormat();\n    } else {\n      outputFormat = (0, _assign2.default)({}, this.defaultFormats.number, outputFormat);\n    }\n\n    return _accounting.default.formatNumber(value, outputFormat.precision, outputFormat.thousand, outputFormat.decimal);\n  }\n  /**\n   * Returns translation for given text key.\n   * @param key\n   * @returns {*|string}\n   */\n\n\n  getTranslation(key) {\n    return this.translations[key];\n  }\n  /**\n   * Returns all translations for current locale.\n   * @returns {*|{}}\n   */\n\n\n  getTranslations() {\n    return this.translations;\n  }\n  /**\n   * Returns true if given key has a translation for currently set locale.\n   * @param key\n   */\n\n\n  hasTranslation(key) {\n    return key in this.translations;\n  }\n  /**\n   * Sets translation for given text key.\n   * @param key\n   * @param translation\n   * @returns {I18N}\n   */\n\n\n  setTranslation(key, translation) {\n    this.translations[key] = translation;\n    return this;\n  }\n  /**\n   * Sets translations that will be used.\n   * @returns {*|{}}\n   */\n\n\n  setTranslations(translations) {\n    this.translations = translations;\n    return this;\n  }\n  /**\n   * Clears all translations.\n   * @returns {*|{}}\n   */\n\n\n  clearTranslations() {\n    this.setTranslations({});\n    return this;\n  }\n  /**\n   * Merges given translations object with already existing.\n   * @returns {*|{}}\n   */\n\n\n  mergeTranslations(translations) {\n    return (0, _assign2.default)(this.translations, translations);\n  }\n  /**\n   * Returns currently selected locale (locale's key).\n   */\n\n\n  getLocale() {\n    return this.locale;\n  }\n  /**\n   * Sets current locale.\n   */\n\n\n  setLocale(locale) {\n    this.locale = locale;\n    return this;\n  }\n  /**\n   * Registers single modifier.\n   * @returns {I18N}\n   */\n\n\n  registerModifier(modifier) {\n    this.modifiers[modifier.name] = modifier;\n    return this;\n  }\n  /**\n   * Registers all modifiers in given array.\n   * @param modifiers\n   * @returns {I18N}\n   */\n\n\n  registerModifiers(modifiers) {\n    modifiers.forEach(modifier => this.registerModifier(modifier));\n    return this;\n  }\n  /**\n   * Unregisters given modifier.\n   * @param name\n   * @returns {I18N}\n   */\n\n\n  unregisterModifier(name) {\n    delete this.modifiers[name];\n    return this;\n  }\n  /**\n   * Registers single processor.\n   * @returns {I18N}\n   */\n\n\n  registerProcessor(processor) {\n    this.processors[processor.name] = processor;\n    return this;\n  }\n  /**\n   * Registers all processors in given array.\n   * @param processors\n   * @returns {I18N}\n   */\n\n\n  registerProcessors(processors) {\n    processors.forEach(processor => this.registerProcessor(processor));\n    return this;\n  }\n  /**\n   * Unregisters given processor.\n   * @param name\n   * @returns {I18N}\n   */\n\n\n  unregisterProcessor(name) {\n    delete this.processors[name];\n    return this;\n  }\n  /**\n   * Returns default formats\n   * @returns {{date: string, time: string, datetime: string, number: string}}\n   */\n\n\n  getDefaultFormats() {\n    return {\n      date: \"DD/MM/YYYY\",\n      time: \"HH:mm\",\n      datetime: \"DD/MM/YYYY HH:mm\",\n      price: {\n        symbol: \"\",\n        format: \"{symbol}{amount}\",\n        decimal: \".\",\n        thousand: \",\",\n        precision: 2\n      },\n      number: {\n        decimal: \".\",\n        thousand: \",\",\n        precision: 2\n      }\n    };\n  }\n  /**\n   * Returns current format to be used when outputting dates.\n   */\n\n\n  getDateFormat() {\n    return (0, _get2.default)(this.locale, \"formats.date\", this.defaultFormats.date);\n  }\n  /**\n   * Returns current format to be used when outputting time.\n   */\n\n\n  getTimeFormat() {\n    return (0, _get2.default)(this.locale, \"formats.time\", this.defaultFormats.time);\n  }\n  /**\n   * Returns current format to be used when outputting date/time.\n   */\n\n\n  getDateTimeFormat() {\n    return (0, _get2.default)(this.locale, \"formats.datetime\", this.defaultFormats.datetime);\n  }\n  /**\n   * Returns current format to be used when outputting prices.\n   */\n\n\n  getPriceFormat() {\n    return (0, _assign2.default)({}, this.defaultFormats.price, (0, _get2.default)(this.locale, \"formats.price\", {}));\n  }\n  /**\n   * Returns current format to be used when outputting numbers.\n   */\n\n\n  getNumberFormat() {\n    return (0, _assign2.default)({}, this.defaultFormats.number, (0, _get2.default)(this.locale, \"formats.number\", {}));\n  }\n\n}\n\nexports.default = I18N;","map":null,"metadata":{},"sourceType":"script"}