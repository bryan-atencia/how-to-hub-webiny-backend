{"ast":null,"code":"import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"Before publishing the main content entry, make sure to publish the\\n                            following referenced entries: {entries}\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nimport React, { useEffect, useState, useMemo } from \"react\";\nimport { I18NValue } from \"@webiny/app-i18n/components\";\nimport { MultiAutoComplete } from \"@webiny/ui/AutoComplete\";\nimport { useQuery } from \"@webiny/app-headless-cms/admin/hooks\";\nimport { useI18N } from \"@webiny/app-i18n/hooks/useI18N\";\nimport get from \"lodash/get\";\nimport debounce from \"lodash/debounce\";\nimport { createListQuery, GET_CONTENT_MODEL } from \"./graphql\";\nimport { i18n } from \"@webiny/app/i18n\";\nimport { Link } from \"@webiny/react-router\";\nvar t = i18n.ns(\"app-headless-cms/admin/fields/ref\");\n\nfunction ContentEntriesMultiAutocomplete(_ref) {\n  var bind = _ref.bind,\n      field = _ref.field; // Value can be an array of object (received from API) or an array of ID (set by the Autocomplete component).\n\n  var value = bind.value.map(function (item) {\n    return get(item, \"id\", item);\n  });\n\n  var _useState = useState(\"\"),\n      _useState2 = _slicedToArray(_useState, 2),\n      search = _useState2[0],\n      setSearch = _useState2[1]; // Format value coming from API\n\n\n  useEffect(function () {\n    if (bind.value.some(function (v) {\n      return typeof v !== \"string\";\n    })) {\n      // We only need IDs to send back in request to API\n      bind.onChange(bind.value.map(function (item) {\n        return get(item, \"id\", item);\n      }));\n    }\n  }, [bind.value]);\n\n  var _useI18N = useI18N(),\n      getValue = _useI18N.getValue; // Fetch ref content model data, so that we can its title field.\n\n\n  var refContentModelQuery = useQuery(GET_CONTENT_MODEL, {\n    variables: {\n      where: {\n        modelId: field.settings.modelId\n      }\n    }\n  });\n  var refContentModel = get(refContentModelQuery, \"data.getContentModel.data\", {}); // Once we have the refContentModel loaded, this will construct proper list and get queries.\n\n  var _useMemo = useMemo(function () {\n    return {\n      LIST_CONTENT: createListQuery(refContentModel)\n    };\n  }, [field.settings.modelId, refContentModel.id]),\n      LIST_CONTENT = _useMemo.LIST_CONTENT; // Once the query in the input has changed, this query will be triggered.\n\n\n  var titleFieldId = refContentModel.titleFieldId;\n  var listContentQuery = useQuery(LIST_CONTENT, {\n    skip: !search || !titleFieldId,\n    variables: {\n      where: _defineProperty({}, \"\".concat(titleFieldId, \"_contains\"), search)\n    }\n  }); // Once we have a valid IDs, we load the data.\n\n  var listContentQueryFilterById = useQuery(LIST_CONTENT, {\n    skip: !value || !titleFieldId,\n    variables: {\n      where: _defineProperty({}, \"id_in\", value)\n    }\n  }); // Format options for the Autocomplete component.\n\n  var options = get(listContentQuery, \"data.content.data\", []).map(function (item) {\n    return {\n      id: item.id,\n      name: getValue(item.meta.title)\n    };\n  }); // Format value prop for the Autocomplete component.\n\n  var valueForAutoComplete = get(listContentQueryFilterById, \"data.content.data\", []).map(function (item) {\n    return {\n      id: item.id,\n      published: item.meta.published,\n      name: getValue(item.meta.title)\n    };\n  }); // Calculate loading prop for the Autocomplete component.\n\n  var loading = listContentQuery.loading || refContentModelQuery.loading || listContentQueryFilterById.loading;\n  var unpublishedEntriesInfo = valueForAutoComplete.filter(function (item) {\n    return item.published === false;\n  });\n\n  if (unpublishedEntriesInfo.length) {\n    unpublishedEntriesInfo = t(_templateObject())({\n      entries: /*#__PURE__*/React.createElement(React.Fragment, null, unpublishedEntriesInfo.map(function (_ref2, index) {\n        var id = _ref2.id,\n            name = _ref2.name,\n            published = _ref2.published;\n        return !published && /*#__PURE__*/React.createElement(React.Fragment, {\n          key: id\n        }, index > 0 && \", \", /*#__PURE__*/React.createElement(Link, {\n          to: \"/cms/content-models/manage/\".concat(refContentModel.modelId, \"?id=\").concat(id)\n        }, name));\n      }))\n    });\n  }\n\n  return /*#__PURE__*/React.createElement(MultiAutoComplete, Object.assign({}, bind, {\n    onChange: function onChange(values) {\n      // We only need IDs to send back in request to API\n      bind.onChange(values.map(function (item) {\n        return get(item, \"id\", item);\n      }));\n    },\n    loading: loading,\n    value: valueForAutoComplete,\n    options: options,\n    label: /*#__PURE__*/React.createElement(I18NValue, {\n      value: field.label\n    }),\n    onInput: debounce(function (search) {\n      return search && setSearch(search);\n    }, 250),\n    description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(I18NValue, {\n      value: field.helpText\n    }), unpublishedEntriesInfo)\n  }));\n}\n\nexport default ContentEntriesMultiAutocomplete;","map":null,"metadata":{},"sourceType":"module"}