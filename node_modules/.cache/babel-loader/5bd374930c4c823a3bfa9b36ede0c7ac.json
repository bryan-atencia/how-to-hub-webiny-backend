{"ast":null,"code":"'use strict';\n/**\n * Set a value by a dot path.\n * @param obj The object to evaluate.\n * @param prop The path to be set.\n * @param val The value to set.\n */\n\nfunction set(obj, prop, value) {\n  prop = typeof prop === 'number' ? propToArray(prop.toString()) : typeof prop === 'string' ? propToArray(prop) : prop;\n\n  var setPropImmutableRec = function (obj, prop, value, i) {\n    var clone,\n        head = prop[i];\n\n    if (prop.length > i) {\n      if (Array.isArray(obj)) {\n        head = getArrayIndex(head, obj);\n        clone = obj.slice();\n      } else {\n        clone = Object.assign({}, obj);\n      }\n\n      clone[head] = setPropImmutableRec(obj[head] !== undefined ? obj[head] : {}, prop, value, i + 1);\n      return clone;\n    }\n\n    return typeof value === 'function' ? value(obj) : value;\n  };\n\n  return setPropImmutableRec(obj, prop, value, 0);\n}\n/**\n * Get a value by a dot path.\n * @param obj The object to evaluate.\n * @param prop The path to value that should be returned.\n * @param value The default value that should be returned when the target doesn't exist.\n */\n\n\nfunction get(obj, prop, value) {\n  prop = typeof prop === 'number' ? propToArray(prop.toString()) : typeof prop === 'string' ? propToArray(prop) : prop;\n\n  for (var i = 0; i < prop.length; i++) {\n    if (obj === null || typeof obj !== 'object') {\n      return value;\n    }\n\n    var head = prop[i];\n\n    if (Array.isArray(obj) && head === '$end') {\n      head = obj.length - 1;\n    }\n\n    obj = obj[head];\n  }\n\n  if (typeof obj === 'undefined') {\n    return value;\n  }\n\n  return obj;\n}\n/**\n * Delete a property by a dot path.\n * If target container is an object, the property is deleted.\n * If target container is an array, the index is deleted.\n * If target container is undefined, nothing is deleted.\n * @param obj The object to evaluate.\n * @param prop The path to the property or index that should be deleted.\n */\n\n\nfunction _delete(obj, prop) {\n  prop = typeof prop === 'number' ? propToArray(prop.toString()) : typeof prop === 'string' ? propToArray(prop) : prop;\n\n  var deletePropImmutableRec = function (obj, prop, i) {\n    var clone,\n        head = prop[i];\n\n    if (obj === null || typeof obj !== 'object' || !Array.isArray(obj) && obj[head] === undefined) {\n      return obj;\n    }\n\n    if (prop.length - 1 > i) {\n      if (Array.isArray(obj)) {\n        head = getArrayIndex(head, obj);\n        clone = obj.slice();\n      } else {\n        clone = Object.assign({}, obj);\n      }\n\n      clone[head] = deletePropImmutableRec(obj[head], prop, i + 1);\n      return clone;\n    }\n\n    if (Array.isArray(obj)) {\n      head = getArrayIndex(head, obj);\n      clone = [].concat(obj.slice(0, head), obj.slice(head + 1));\n    } else {\n      clone = Object.assign({}, obj);\n      delete clone[head];\n    }\n\n    return clone;\n  };\n\n  return deletePropImmutableRec(obj, prop, 0);\n}\n/**\n * Toggles a value.  The target value is evaluated using Boolean(currentValue).  The result will always be a JSON boolean.\n * Be careful with strings as target value, as \"true\" and \"false\" will toggle to false, but \"0\" will toggle to true.\n * Here is what Javascript considers false:  0, -0, null, false, NaN, undefined, and the empty string (\"\")\n * @param obj The object to evaluate.\n * @param prop The path to the value.\n */\n\n\nfunction toggle(obj, prop) {\n  var curVal = get(obj, prop);\n  return set(obj, prop, !Boolean(curVal));\n}\n/**\n * Merges a value.  The target value must be an object, array, null, or undefined.\n * If target is an object, Object.assign({}, target, param) is used.\n * If target an array, target.concat(param) is used.\n * If target is null or undefined, the value is simply set.\n * @param obj The object to evaluate.\n * @param prop The path to the value.\n * @param val The value to merge into the target value.\n */\n\n\nfunction merge(obj, prop, val) {\n  var curVal = get(obj, prop);\n\n  if (typeof curVal === 'object') {\n    if (Array.isArray(curVal)) {\n      return set(obj, prop, curVal.concat(val));\n    } else if (curVal === null) {\n      return set(obj, prop, val);\n    } else {\n      var merged = Object.assign({}, curVal, val);\n      return set(obj, prop, merged);\n    }\n  } else if (typeof curVal === 'undefined') {\n    return set(obj, prop, val);\n  } else {\n    return obj;\n  }\n}\n\nfunction getArrayIndex(head, obj) {\n  if (head === '$end') {\n    head = Math.max(obj.length - 1, 0);\n  }\n\n  if (!/^\\+?\\d+$/.test(head)) {\n    throw new Error('Array index \\'' + head + '\\' has to be an integer');\n  }\n\n  return parseInt(head);\n}\n\nfunction propToArray(prop) {\n  return prop.split('.').reduce(function (ret, el, index, list) {\n    var last = index > 0 && list[index - 1];\n\n    if (last && /(?:^|[^\\\\])\\\\$/.test(last)) {\n      ret.pop();\n      ret.push(last.slice(0, -1) + '.' + el);\n    } else {\n      ret.push(el);\n    }\n\n    return ret;\n  }, []);\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  delete: _delete,\n  toggle: toggle,\n  merge: merge\n};","map":null,"metadata":{},"sourceType":"script"}