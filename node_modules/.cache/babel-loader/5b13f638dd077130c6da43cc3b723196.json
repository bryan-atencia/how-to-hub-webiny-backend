{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/bryanatencia/demo/how-to-demo-backend-webiny/how-to-demo-backend-webiny/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport isPlainObject from 'is-plain-object';\nimport { Operation, Editor, Path } from 'slate';\nvar History = {\n  /**\r\n   * Check if a value is a `History` object.\r\n   */\n  isHistory: function isHistory(value) {\n    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0]));\n  }\n};\n/**\r\n * Weakmaps for attaching state to the editor.\r\n */\n\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap();\nvar HistoryEditor = {\n  /**\r\n   * Check if a value is a `HistoryEditor` object.\r\n   */\n  isHistoryEditor: function isHistoryEditor(value) {\n    return Editor.isEditor(value) && History.isHistory(value.history);\n  },\n\n  /**\r\n   * Get the merge flag's current value.\r\n   */\n  isMerging: function isMerging(editor) {\n    return MERGING.get(editor);\n  },\n\n  /**\r\n   * Get the saving flag's current value.\r\n   */\n  isSaving: function isSaving(editor) {\n    return SAVING.get(editor);\n  },\n\n  /**\r\n   * Redo to the previous saved state.\r\n   */\n  redo: function redo(editor) {\n    editor.redo();\n  },\n\n  /**\r\n   * Undo to the previous saved state.\r\n   */\n  undo: function undo(editor) {\n    editor.undo();\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\r\n   * the new operations into previous save point in the history.\r\n   */\n  withoutMerging: function withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\r\n   * their operations into the history.\r\n   */\n  withoutSaving: function withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  }\n};\n/**\r\n * The `withHistory` plugin keeps track of the operation history of a Slate\r\n * editor as operations are applied to it, using undo and redo stacks.\r\n */\n\nvar withHistory = function withHistory(editor) {\n  var e = editor;\n  var apply = e.apply;\n  e.history = {\n    undos: [],\n    redos: []\n  };\n\n  e.redo = function () {\n    var history = e.history;\n    var redos = history.redos;\n\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n      HistoryEditor.withoutSaving(e, function () {\n        Editor.withoutNormalizing(e, function () {\n          var _iterator = _createForOfIteratorHelper(batch),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var op = _step.value;\n              e.apply(op);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      });\n      history.redos.pop();\n      history.undos.push(batch);\n    }\n  };\n\n  e.undo = function () {\n    var history = e.history;\n    var undos = history.undos;\n\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e, function () {\n        Editor.withoutNormalizing(e, function () {\n          var inverseOps = batch.map(Operation.inverse).reverse();\n\n          var _iterator2 = _createForOfIteratorHelper(inverseOps),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var op = _step2.value;\n\n              // If the final operation is deselecting the editor, skip it. This is\n              if (op === inverseOps[inverseOps.length - 1] && op.type === 'set_selection' && op.newProperties == null) {\n                continue;\n              } else {\n                e.apply(op);\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        });\n      });\n      history.redos.push(batch);\n      history.undos.pop();\n    }\n  };\n\n  e.apply = function (op) {\n    var operations = e.operations,\n        history = e.history;\n    var undos = history.undos;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch[lastBatch.length - 1];\n    var overwrite = shouldOverwrite(op, lastOp);\n    var save = HistoryEditor.isSaving(e);\n    var merge = HistoryEditor.isMerging(e);\n\n    if (save == null) {\n      save = shouldSave(op);\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp) || overwrite;\n        }\n      }\n\n      if (lastBatch && merge) {\n        if (overwrite) {\n          lastBatch.pop();\n        }\n\n        lastBatch.push(op);\n      } else {\n        var batch = [op];\n        undos.push(batch);\n      }\n\n      while (undos.length > 100) {\n        undos.shift();\n      }\n\n      if (shouldClear(op)) {\n        history.redos = [];\n      }\n    }\n\n    apply(op);\n  };\n\n  return e;\n};\n/**\r\n * Check whether to merge an operation into the previous operation.\r\n */\n\n\nvar shouldMerge = function shouldMerge(op, prev) {\n  if (op.type === 'set_selection') {\n    return true;\n  }\n\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation needs to be saved to the history.\r\n */\n\n\nvar shouldSave = function shouldSave(op, prev) {\n  if (op.type === 'set_selection' && op.newProperties == null) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Check whether an operation should overwrite the previous one.\r\n */\n\n\nvar shouldOverwrite = function shouldOverwrite(op, prev) {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation should clear the redos stack.\r\n */\n\n\nvar shouldClear = function shouldClear(op) {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n\n  return true;\n};\n\nexport { HISTORY, History, HistoryEditor, MERGING, SAVING, withHistory };","map":null,"metadata":{},"sourceType":"module"}