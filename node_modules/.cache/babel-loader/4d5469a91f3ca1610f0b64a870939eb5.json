{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport * as React from \"react\";\nimport Downshift from \"downshift\";\nimport MaterialSpinner from \"react-spinner-material\";\nimport { Input } from \"@webiny/ui/Input\";\nimport { Chips, Chip } from \"@webiny/ui/Chips\";\nimport { getOptionValue, getOptionText } from \"./utils\";\nimport { ReactComponent as BaselineCloseIcon } from \"@svgr/webpack!./icons/baseline-close-24px.svg\";\nimport classNames from \"classnames\";\nimport { Elevation } from \"@webiny/ui/Elevation\";\nimport { Typography } from \"@webiny/ui/Typography\";\nimport { autoCompleteStyle, suggestionList } from \"./styles\";\n\nfunction Spinner() {\n  if (process.env.REACT_APP_ENV === \"ssr\") {\n    return null;\n  }\n\n  return /*#__PURE__*/React.createElement(MaterialSpinner, {\n    size: 24,\n    spinnerColor: \"#fa5723\",\n    spinnerWidth: 2,\n    visible: true\n  });\n}\n\nexport var MultiAutoComplete = /*#__PURE__*/function (_React$Component) {\n  _inherits(MultiAutoComplete, _React$Component);\n\n  var _super = _createSuper(MultiAutoComplete);\n\n  function MultiAutoComplete() {\n    var _this;\n\n    _classCallCheck(this, MultiAutoComplete);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      inputValue: \"\"\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"downshift\", /*#__PURE__*/React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"assignedValueAfterClearing\", {\n      set: false,\n      selection: null\n    });\n\n    return _this;\n  }\n\n  _createClass(MultiAutoComplete, [{\n    key: \"getOptions\",\n    value: function getOptions() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          unique = _this$props.unique,\n          value = _this$props.value,\n          allowFreeInput = _this$props.allowFreeInput,\n          useSimpleValues = _this$props.useSimpleValues,\n          options = _this$props.options;\n      var filtered = options.filter(function (item) {\n        // We need to filter received options.\n        // 1) If \"unique\" prop was passed, we don't want to show already picked options again.\n        if (unique) {\n          var values = value;\n\n          if (Array.isArray(values)) {\n            if (values.find(function (value) {\n              return getOptionValue(value, _this2.props) === getOptionValue(item, _this2.props);\n            })) {\n              return false;\n            }\n          }\n        } // 2) At the end, we want to show only options that are matched by typed text.\n\n\n        if (!_this2.state.inputValue) {\n          return true;\n        }\n\n        return getOptionText(item, _this2.props).toLowerCase().includes(_this2.state.inputValue.toLowerCase());\n      }); // If free input is allowed, prepend typed value to the list.\n\n      if (allowFreeInput && this.state.inputValue) {\n        if (useSimpleValues) {\n          var existingValue = filtered.includes(this.state.inputValue);\n\n          if (!existingValue) {\n            filtered.unshift(this.state.inputValue);\n          }\n        } else {\n          var _existingValue = filtered.find(function (item) {\n            return _this2.state.inputValue === getOptionText(item, _this2.props);\n          });\n\n          if (!_existingValue) {\n            filtered.unshift(_defineProperty({}, this.props.textProp, this.state.inputValue));\n          }\n        }\n      }\n\n      return filtered;\n    }\n    /**\n     * Renders options - based on user's input. It will try to match input text with available options.\n     * @param options\n     * @param isOpen\n     * @param highlightedIndex\n     * @param selectedItem\n     * @param getMenuProps\n     * @param getItemProps\n     * @returns {*}\n     */\n\n  }, {\n    key: \"renderOptions\",\n    value: function renderOptions(_ref) {\n      var _this3 = this;\n\n      var options = _ref.options,\n          isOpen = _ref.isOpen,\n          highlightedIndex = _ref.highlightedIndex,\n          getMenuProps = _ref.getMenuProps,\n          getItemProps = _ref.getItemProps;\n\n      if (!isOpen) {\n        return null;\n      }\n\n      if (!options.length) {\n        return /*#__PURE__*/React.createElement(Elevation, {\n          z: 1\n        }, /*#__PURE__*/React.createElement(\"ul\", getMenuProps(), /*#__PURE__*/React.createElement(\"li\", null, /*#__PURE__*/React.createElement(Typography, {\n          use: \"body2\"\n        }, \"No results.\"))));\n      }\n\n      var renderItem = this.props.renderItem;\n      return /*#__PURE__*/React.createElement(Elevation, {\n        z: 1\n      }, /*#__PURE__*/React.createElement(\"ul\", getMenuProps(), options.map(function (item, index) {\n        var _itemClassNames;\n\n        var itemValue = getOptionValue(item, _this3.props); // Base classes.\n\n        var itemClassNames = (_itemClassNames = {}, _defineProperty(_itemClassNames, suggestionList, true), _defineProperty(_itemClassNames, \"highlighted\", highlightedIndex === index), _defineProperty(_itemClassNames, \"selected\", false), _itemClassNames); // Render the item.\n\n        return /*#__PURE__*/React.createElement(\"li\", Object.assign({\n          key: itemValue + index\n        }, getItemProps({\n          index: index,\n          item: item,\n          className: classNames(itemClassNames)\n        })), renderItem.call(_this3, item, index));\n      })));\n    }\n    /**\n     * Once added, items can also be removed by clicking on the âœ• icon. This is the method that is responsible for\n     * rendering selected items (we are using already existing \"Chips\" component).\n     * @returns {*}\n     */\n\n  }, {\n    key: \"renderMultipleSelection\",\n    value: function renderMultipleSelection() {\n      var _this4 = this;\n\n      var _this$props2 = this.props,\n          value = _this$props2.value,\n          onChange = _this$props2.onChange,\n          disabled = _this$props2.disabled;\n      return /*#__PURE__*/React.createElement(React.Fragment, null, Array.isArray(value) && value.length ? /*#__PURE__*/React.createElement(Chips, {\n        disabled: disabled\n      }, value.map(function (item, index) {\n        return /*#__PURE__*/React.createElement(Chip, {\n          label: getOptionText(item, _this4.props),\n          key: \"\".concat(getOptionValue(item, _this4.props), \"-\").concat(index),\n          trailingIcon: /*#__PURE__*/React.createElement(BaselineCloseIcon, null),\n          onRemove: function onRemove() {\n            // On removal, let's update the value and call \"onChange\" callback.\n            if (onChange) {\n              var newValue = _toConsumableArray(value);\n\n              newValue.splice(index, 1);\n              onChange(newValue);\n            }\n          }\n        });\n      })) : null);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var props = this.props,\n          _this$props3 = this.props,\n          rawOptions = _this$props3.options,\n          allowFreeInput = _this$props3.allowFreeInput,\n          useSimpleValues = _this$props3.useSimpleValues,\n          unique = _this$props3.unique,\n          value = _this$props3.value,\n          _onChange = _this$props3.onChange,\n          valueProp = _this$props3.valueProp,\n          textProp = _this$props3.textProp,\n          onInput = _this$props3.onInput,\n          _this$props3$validati = _this$props3.validation,\n          validation = _this$props3$validati === void 0 ? {\n        isValid: null\n      } : _this$props3$validati,\n          otherInputProps = _objectWithoutProperties(_this$props3, [\"options\", \"allowFreeInput\", \"useSimpleValues\", \"unique\", \"value\", \"onChange\", \"valueProp\", \"textProp\", \"onInput\", \"validation\"]);\n\n      var options = this.getOptions();\n      return /*#__PURE__*/React.createElement(\"div\", {\n        className: autoCompleteStyle\n      }, /*#__PURE__*/React.createElement(Downshift, {\n        defaultSelectedItem: null // @ts-ignore\n        ,\n        className: autoCompleteStyle,\n        itemToString: function itemToString(item) {\n          return item && getOptionText(item, props);\n        },\n        ref: this.downshift,\n        onChange: function onChange(selection) {\n          if (!_this5.assignedValueAfterClearing.set) {\n            _this5.assignedValueAfterClearing = {\n              set: true,\n              selection: selection\n            };\n\n            _this5.downshift.current.clearSelection();\n\n            return;\n          }\n\n          if (_this5.assignedValueAfterClearing.set) {\n            _this5.assignedValueAfterClearing.set = false;\n\n            if (Array.isArray(value)) {\n              _onChange && _onChange([].concat(_toConsumableArray(value), [_this5.assignedValueAfterClearing.selection]));\n            } else {\n              _onChange && _onChange([_this5.assignedValueAfterClearing.selection]);\n            }\n          }\n        }\n      }, function (_ref2) {\n        var getInputProps = _ref2.getInputProps,\n            openMenu = _ref2.openMenu,\n            rest = _objectWithoutProperties(_ref2, [\"getInputProps\", \"openMenu\"]);\n\n        return /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(Input, getInputProps(_objectSpread(_objectSpread({}, otherInputProps), {}, {\n          // @ts-ignore\n          validation: validation,\n          rawOnChange: true,\n          trailingIcon: _this5.props.loading && /*#__PURE__*/React.createElement(Spinner, null),\n          onChange: function onChange(e) {\n            return e;\n          },\n          onBlur: function onBlur(e) {\n            return e;\n          },\n          onKeyUp: function onKeyUp(e) {\n            var inputValue = e.target.value || \"\"; // Set current input value into state and trigger onInput if different.\n\n            if (inputValue !== _this5.state.inputValue) {\n              _this5.setState({\n                inputValue: inputValue\n              }, function () {\n                onInput && onInput(inputValue);\n              });\n            }\n          },\n          onFocus: function onFocus(e) {\n            openMenu();\n            otherInputProps.onFocus && otherInputProps.onFocus(e);\n          }\n        }))), _this5.renderOptions(_objectSpread(_objectSpread({}, rest), {}, {\n          unique: unique,\n          options: options\n        })), _this5.renderMultipleSelection());\n      }));\n    }\n  }]);\n\n  return MultiAutoComplete;\n}(React.Component);\n\n_defineProperty(MultiAutoComplete, \"defaultProps\", {\n  valueProp: \"id\",\n  textProp: \"name\",\n  unique: true,\n  options: [],\n  useSimpleValues: false,\n  renderItem: function renderItem(item) {\n    return /*#__PURE__*/React.createElement(Typography, {\n      use: \"body2\"\n    }, getOptionText(item, this.props));\n  }\n});","map":null,"metadata":{},"sourceType":"module"}