{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport React from \"react\";\nimport { set } from \"dot-prop-immutable\";\nimport { useApolloClient } from \"react-apollo\";\nimport { useSnackbar } from \"@webiny/app-admin/hooks/useSnackbar\";\nimport { PUBLISH_REVISION, GET_PAGE } from \"@webiny/app-page-builder/admin/graphql/pages\";\nexport function usePublishRevisionHandler(_ref) {\n  var page = _ref.page;\n  var client = useApolloClient();\n\n  var _useSnackbar = useSnackbar(),\n      showSnackbar = _useSnackbar.showSnackbar;\n\n  var publishRevision = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(revision) {\n      var _yield$client$mutate, res, error;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return client.mutate({\n                mutation: PUBLISH_REVISION,\n                variables: {\n                  id: revision.id\n                },\n                refetchQueries: [\"PbListPages\"],\n                update: function update(cache, _ref3) {\n                  var data = _ref3.data; // Don't do anything if there was an error during publishing!\n\n                  if (data.pageBuilder.publishRevision.error) {\n                    return;\n                  }\n\n                  var getPageQuery = GET_PAGE(); // Update revisions\n\n                  var pageFromCache = cache.readQuery({\n                    query: getPageQuery,\n                    variables: {\n                      id: page.id\n                    }\n                  });\n                  page.revisions.forEach(function (r) {\n                    // Update published/locked fields on the revision that was just published.\n                    if (r.id === revision.id) {\n                      r.published = true;\n                      r.locked = true;\n                      return;\n                    } // Unpublish other published revisions\n\n\n                    if (r.published) {\n                      r.published = false;\n                    }\n                  }); // Write our data back to the cache.\n\n                  cache.writeQuery({\n                    query: getPageQuery,\n                    data: set(pageFromCache, \"pageBuilder.page.data\", page)\n                  });\n                }\n              });\n\n            case 2:\n              _yield$client$mutate = _context.sent;\n              res = _yield$client$mutate.data;\n              error = res.pageBuilder.publishRevision.error;\n\n              if (!error) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt(\"return\", showSnackbar(error.message));\n\n            case 7:\n              showSnackbar( /*#__PURE__*/React.createElement(\"span\", null, \"Successfully published revision \", /*#__PURE__*/React.createElement(\"strong\", null, \"#\", revision.version), \"!\"));\n\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function publishRevision(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  return {\n    publishRevision: publishRevision\n  };\n}","map":null,"metadata":{},"sourceType":"module"}