import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _pick from "lodash/pick";
import _cloneDeep from "lodash/cloneDeep";
import _get from "lodash/get";
import React from "react";
import shortid from "shortid";
import { GET_FORM, UPDATE_REVISION } from "./graphql";
import { getFieldPosition as _getFieldPosition, moveField as _moveField, moveRow as _moveRow, deleteField as _deleteField } from "./functions";
import { getPlugins } from "@webiny/plugins";
export default (function (FormEditorContext) {
  return function () {
    // TODO: @ts-adrian add proper type
    var context = React.useContext(FormEditorContext);

    if (!context) {
      throw new Error("useFormEditor must be used within a FormEditorProvider");
    }

    var state = context.state,
        dispatch = context.dispatch;
    var self = {
      apollo: state.apollo,
      data: state.data,
      state: state,
      getForm: function getForm(id) {
        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
          var response, _get2, data, error;

          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return self.apollo.query({
                    query: GET_FORM,
                    variables: {
                      id: id
                    }
                  });

                case 2:
                  response = _context.sent;
                  _get2 = _get(response, "data.forms.getForm"), data = _get2.data, error = _get2.error;

                  if (!error) {
                    _context.next = 6;
                    break;
                  }

                  throw new Error(error);

                case 6:
                  self.setData(function () {
                    var form = _cloneDeep(data);

                    if (!form.settings.layout.renderer) {
                      form.settings.layout.renderer = state.defaultLayoutRenderer;
                    }

                    return form;
                  }, false);
                  return _context.abrupt("return", response);

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      saveForm: function () {
        var _saveForm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(data) {
          var response;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  data = data || state.data;
                  _context2.next = 3;
                  return self.apollo.mutate({
                    mutation: UPDATE_REVISION,
                    variables: {
                      id: data.id,
                      data: _pick(data, ["layout", "fields", "name", "settings", "triggers"])
                    }
                  });

                case 3:
                  response = _context2.sent;
                  return _context2.abrupt("return", _get(response, "data.forms.updateRevision"));

                case 5:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        function saveForm(_x) {
          return _saveForm.apply(this, arguments);
        }

        return saveForm;
      }(),

      /**
       * Set form data by providing a callback, which receives a fresh copy of data on which you can work on.
       * Return new data once finished.
       * @param setter
       * @param saveForm
       */
      setData: function setData(setter) {
        var saveForm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var data = setter(_cloneDeep(self.data));
        dispatch({
          type: "data",
          data: data
        });
        saveForm !== false && self.saveForm(data);
      },

      /**
       * Returns fields list or complete layout with fields data in it (not just field IDs).
       * @param layout
       * @returns {*}
       */
      getFields: function getFields() {
        var layout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (!layout) {
          return state.data.fields;
        } // Replace every field ID with actual field object.


        var fields = _cloneDeep(state.data.layout);

        fields.forEach(function (row, rowIndex) {
          row.forEach(function (fieldId, fieldIndex) {
            fields[rowIndex][fieldIndex] = self.getField({
              _id: fieldId
            });
          });
        });
        return fields;
      },

      /**
       * Return field plugin.
       * @param query
       * @returns {void|?FbFormModelField}
       */
      getFieldPlugin: function getFieldPlugin(query) {
        return getPlugins("form-editor-field-type").find(function (_ref) {
          var field = _ref.field;

          for (var key in query) {
            if (!(key in field)) {
              return null;
            }

            if (field[key] !== query[key]) {
              return null;
            }
          }

          return true;
        });
      },

      /**
       * Checks if field of given type already exists in the list of fields.
       * @param query
       * @returns {boolean}
       */
      getField: function getField(query) {
        return state.data.fields.find(function (field) {
          for (var key in query) {
            if (!(key in field)) {
              return null;
            }

            if (field[key] !== query[key]) {
              return null;
            }
          }

          return true;
        });
      },

      /**
       * Inserts a new field into the target position.
       * @param data
       * @param position
       */
      insertField: function insertField(data, position) {
        var field = _cloneDeep(data);

        if (!field._id) {
          field._id = shortid.generate();
        }

        if (!data.name) {
          throw new Error("Field \"name\" missing.");
        }

        var fieldPlugin = self.getFieldPlugin({
          name: data.name
        });

        if (!fieldPlugin) {
          throw new Error("Invalid field \"name\".");
        }

        data.type = fieldPlugin.field.type;
        self.setData(function (data) {
          if (!Array.isArray(data.fields)) {
            data.fields = [];
          }

          data.fields.push(field);

          _moveField({
            field: field,
            position: position,
            data: data
          }); // We are dropping a new field at the specified index.


          return data;
        });
      },

      /**
       * Moves field to the given target position.
       * @param field
       * @param position
       * @param data
       */
      moveField: function moveField(_ref2) {
        var field = _ref2.field,
            position = _ref2.position;
        self.setData(function (data) {
          _moveField({
            field: field,
            position: position,
            data: data
          });

          return data;
        });
      },

      /**
       * Moves row to a destination row.
       * @param source
       * @param destination
       */
      moveRow: function moveRow(source, destination) {
        self.setData(function (data) {
          _moveRow({
            data: data,
            source: source,
            destination: destination
          });

          return data;
        });
      },

      /**
       * Updates field.
       * @param fieldData
       */
      updateField: function updateField(fieldData) {
        var field = _cloneDeep(fieldData);

        self.setData(function (data) {
          for (var i = 0; i < data.fields.length; i++) {
            if (data.fields[i]._id === field._id) {
              data.fields[i] = field;
              break;
            }
          }

          return data;
        });
      },

      /**
       * Deletes a field (both from the list of field and the layout).
       * @param field
       */
      deleteField: function deleteField(field) {
        self.setData(function (data) {
          _deleteField({
            field: field,
            data: data
          });

          return data;
        });
      },

      /**
       * Returns row / index position for given field.
       * @param field
       * @returns {{index: number, row: number}|{index: null, row: null}}
       */
      getFieldPosition: function getFieldPosition(field) {
        return _getFieldPosition({
          field: field,
          data: self.data
        });
      }
    };
    return self;
  };
});
//# sourceMappingURL=useFormEditorFactory.js.map