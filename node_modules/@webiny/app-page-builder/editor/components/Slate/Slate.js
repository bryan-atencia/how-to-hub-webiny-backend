import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _createSuper from "@babel/runtime/helpers/createSuper";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _noop from "lodash/noop";
import _isEqual from "lodash/isEqual";
import _get from "lodash/get";
import React from "react";
import ReactDOM from "react-dom";
import shortid from "shortid";
import { Editor } from "slate-react";
import { Value } from "slate";
import { getPlugins } from "@webiny/plugins";
import { usePageBuilder } from "@webiny/app-page-builder/hooks/usePageBuilder";
import { createValue } from "./index";
import Menu from "./Menu";

var valueToJSON = function valueToJSON(value) {
  return {
    selection: value.selection.toJSON(),
    anchorText: value.anchorText.getText(),
    focusText: value.focusText.getText(),
    inlines: value.inlines.toJSON(),
    marks: value.marks.toJSON(),
    activeMarks: value.activeMarks.toJSON(),
    blocks: value.blocks.toJSON(),
    texts: value.texts.toJSON()
  };
};

var SlateEditor = /*#__PURE__*/function (_React$Component) {
  _inherits(SlateEditor, _React$Component);

  var _super = _createSuper(SlateEditor);

  function SlateEditor(props) {
    var _this;

    _classCallCheck(this, SlateEditor);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "id", void 0);

    _defineProperty(_assertThisInitialized(_this), "nextElement", void 0);

    _defineProperty(_assertThisInitialized(_this), "plugins", []);

    _defineProperty(_assertThisInitialized(_this), "editor", /*#__PURE__*/React.createRef());

    _defineProperty(_assertThisInitialized(_this), "trackNextElement", function (e) {
      // Store the clicked element. If it is set, it means we clicked inside the editor div.
      _this.nextElement = e.target;
    });

    _defineProperty(_assertThisInitialized(_this), "untrackNextElement", function () {
      _this.nextElement = null;
    });

    _defineProperty(_assertThisInitialized(_this), "onChange", function (change) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _noop;

      if (_this.state.readOnly) {
        return;
      } // Prevent `onChange` if it is a `set_value` operation.
      // We only need to handle changes on user input.


      var operations = change.operations.toJSON();

      if (_get(operations, "0.type") === "set_value") {
        return;
      } // Only update local state.


      _this.setState(function (state) {
        return _objectSpread(_objectSpread({}, state), {}, {
          value: change.value,
          modified: true
        });
      }, callback);
    });

    _defineProperty(_assertThisInitialized(_this), "onBlur", function () {
      // Do not save changes if there is a plugin that's still active. This can happen, for example, when
      // you click on the "Link" tool, which opens a dialog, which then triggers the blur event and this callback.
      if (_this.state.activePlugin) {
        return;
      }

      if (!_this.nextElement) {
        _this.setState({
          modified: false
        });

        _this.props.onChange(_this.state.value.toJSON());
      }
    });

    _defineProperty(_assertThisInitialized(_this), "getMenuContainer", function () {
      var id = "slate-menu-container"; // Get menu container

      var menuContainer = document.getElementById(id);

      if (!menuContainer) {
        menuContainer = document.createElement("div");
        menuContainer.setAttribute("id", id);
        document.body && document.body.appendChild(menuContainer);
      } // Position menu container


      var rect = _this.getSelectionRect();

      if (rect.top === 0) {
        return menuContainer;
      }

      menuContainer.style.position = "fixed";
      menuContainer.style.pointerEvents = "none";
      menuContainer.style.zIndex = "4";
      menuContainer.style.top = rect.top - 20 + "px";
      menuContainer.style.left = rect.left + "px";
      menuContainer.style.width = rect.width + "px";
      menuContainer.style.height = rect.height + "px";
      return menuContainer;
    });

    _defineProperty(_assertThisInitialized(_this), "getSelectionRect", function () {
      var native = window.getSelection();

      if (native.type === "None") {
        return {
          top: 0,
          left: 0,
          width: 0,
          height: 0
        };
      }

      var range = native.getRangeAt(0);
      return range.getBoundingClientRect();
    });

    _defineProperty(_assertThisInitialized(_this), "renderFloatingMenu", function () {
      var container = _this.getMenuContainer();

      if (container) {
        return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(Menu, {
          exclude: _this.props.exclude,
          value: _this.state.value,
          onChange: _this.onChange,
          editor: _this.editor,
          activatePlugin: _this.activatePlugin,
          activePlugin: _this.state.activePlugin,
          deactivatePlugin: _this.deactivatePlugin
        }), container);
      }

      return null;
    });

    _defineProperty(_assertThisInitialized(_this), "activatePlugin", function (plugin) {
      var value = _this.state.value;

      _this.setState({
        activePlugin: {
          plugin: plugin,
          value: valueToJSON(value)
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this), "deactivatePlugin", function () {
      _this.setState({
        activePlugin: null
      });
    });

    _this.id = shortid.generate();
    _this.nextElement = null;

    var _value = typeof props.value === "string" ? createValue(props.value) : props.value;

    _this.state = {
      modified: false,
      showMenu: false,
      value: Value.fromJSON(_value),
      readOnly: !props.onChange,
      activePlugin: null
    };
    var plugins = getPlugins("pb-editor-slate-editor");
    _this.plugins = plugins.filter(function (pl) {
      return !props.exclude.includes(pl.name);
    }).map(function (pl) {
      return pl.slate;
    });
    return _this;
  }

  _createClass(SlateEditor, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      document.getElementById(this.id).addEventListener("mousedown", this.trackNextElement);
      document.getElementById(this.id).addEventListener("mouseup", this.untrackNextElement);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      document.getElementById(this.id).removeEventListener("mousedown", this.trackNextElement);
      document.getElementById(this.id).removeEventListener("mouseup", this.untrackNextElement);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var activePlugin = this.state.activePlugin;
      return /*#__PURE__*/React.createElement("div", {
        id: this.id
      }, !this.state.readOnly && this.renderFloatingMenu(), /*#__PURE__*/React.createElement(WithPageBuilderTheme, null, function (_ref) {
        var theme = _ref.theme;
        return /*#__PURE__*/React.createElement(Editor, {
          ref: _this2.editor,
          onBlur: _this2.onBlur,
          readOnly: _this2.state.readOnly,
          autoCorrect: false,
          spellCheck: false,
          plugins: _this2.plugins,
          placeholder: "Enter some text...",
          value: _this2.state.value,
          onChange: _this2.onChange,
          theme: theme,
          activatePlugin: function activatePlugin(name) {
            return _this2.activatePlugin(name);
          },
          activePlugin: _this2.state.activePlugin,
          deactivatePlugin: _this2.deactivatePlugin
        });
      }), getPlugins("pb-editor-slate-menu-item").filter(function (pl) {
        return typeof pl.renderDialog === "function";
      }).map(function (pl) {
        var props = {
          onChange: function onChange(change) {
            // For dialogs, we send a complete callback, which will not only update the state of
            // the Slate editor, but will also save the changes via GraphQL mutation.
            _this2.onChange(change, function () {
              return _this2.props.onChange(_this2.state.value.toJSON());
            });

            _this2.setState({
              modified: false
            });
          },
          editor: _this2.editor.current,
          open: activePlugin ? activePlugin.plugin === pl.name : false,
          closeDialog: _this2.deactivatePlugin,
          activePlugin: activePlugin,
          activatePlugin: function activatePlugin(name) {
            return _this2.activatePlugin(name);
          }
        };
        return /*#__PURE__*/React.cloneElement(pl.renderDialog(props), {
          key: pl.name
        });
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if (!state.modified && !props.readOnly) {
        // Got new editor value through props.
        var _value2 = typeof props.value === "string" ? createValue(props.value) : props.value;

        if (_isEqual(_value2, state.value.toJSON())) {
          return null;
        }

        return {
          value: Value.fromJSON(_value2)
        };
      }

      return null;
    }
  }]);

  return SlateEditor;
}(React.Component);

_defineProperty(SlateEditor, "defaultProps", {
  exclude: []
});

var WithPageBuilderTheme = function WithPageBuilderTheme(_ref2) {
  var children = _ref2.children;

  var _usePageBuilder = usePageBuilder(),
      theme = _usePageBuilder.theme;

  return children({
    theme: theme
  });
};

export default SlateEditor;
//# sourceMappingURL=Slate.js.map