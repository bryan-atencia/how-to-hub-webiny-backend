{"version":3,"sources":["../../../../src/editor/components/Editor/DragPreview.tsx"],"names":["React","useEffect","useState","useDragLayer","layerStyles","position","pointerEvents","zIndex","left","top","width","height","subscribedToOffsetChange","dragPreviewRef","onOffsetChange","monitor","offset","getClientOffset","transform","x","y","style","DragPreview","dragHelperOpacity","setDragHelperOpacity","subscribeToOffsetChange","isDragging","setTimeout","el","display","opacity","transition","backgroundColor","borderRadius"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport { DragLayerMonitor, useDragLayer } from \"react-dnd\";\n\nconst layerStyles: React.CSSProperties = {\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    zIndex: 100,\n    left: 0,\n    top: 0,\n    width: \"100%\",\n    height: \"100%\"\n};\n\nlet subscribedToOffsetChange = false;\n\nlet dragPreviewRef = null;\n\nconst onOffsetChange = monitor => () => {\n    if (!dragPreviewRef) {\n        return;\n    }\n\n    const offset = monitor.getClientOffset();\n    if (!offset) {\n        return;\n    }\n\n    const transform = `translate(${offset.x - 15}px, ${offset.y - 15}px)`;\n    dragPreviewRef.style[\"transform\"] = transform;\n    dragPreviewRef.style[\"-webkit-transform\"] = transform;\n};\n\nexport default function DragPreview() {\n    const [dragHelperOpacity, setDragHelperOpacity] = useState(0);\n    const { isDragging } = useDragLayer((monitor: DragLayerMonitor) => {\n        if (!subscribedToOffsetChange) {\n            // @ts-ignore\n            monitor.subscribeToOffsetChange(onOffsetChange(monitor));\n            subscribedToOffsetChange = true;\n        }\n\n        return {\n            isDragging: monitor.isDragging()\n        };\n    });\n\n    useEffect(() => {\n        return () => {\n            subscribedToOffsetChange = false;\n            dragPreviewRef = null;\n        };\n    }, []);\n\n    // We track the value of \"isDragging\" and apply opacity=1 (after 100ms), when it switches to true.\n    // Without this, the drag cursor would be shown in the top-left corner for a short amount of time, and then it\n    // would be repositioned correctly. Definitely looks like a glitch. This also adds a nice little fade-in effect.\n    useEffect(() => {\n        if (isDragging) {\n            setTimeout(() => {\n                setDragHelperOpacity(isDragging ? 1 : 0);\n            }, 100);\n        } else {\n            setDragHelperOpacity(0);\n        }\n    }, [isDragging]);\n\n    if (!isDragging) {\n        return null;\n    }\n\n    return (\n        <div style={layerStyles}>\n            <div\n                ref={el => (dragPreviewRef = el)}\n                style={{\n                    display: \"block\",\n                    opacity: dragHelperOpacity,\n                    transition: \"opacity .25s ease-in-out\"\n                }}\n            >\n                <div\n                    style={{\n                        width: 30,\n                        height: 30,\n                        backgroundColor: \"var(--mdc-theme-primary)\",\n                        borderRadius: \"50%\"\n                    }}\n                />\n            </div>\n        </div>\n    );\n}\n"],"file":"DragPreview.js"}