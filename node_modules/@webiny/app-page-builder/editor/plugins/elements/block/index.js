import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import React from "react";
import { redux } from "@webiny/app-page-builder/editor/redux";
import Block from "./Block";
import { set } from "dot-prop-immutable";
import { createElement, createRow, createColumn, cloneElement, addElementToParent } from "@webiny/app-page-builder/editor/utils";
import { updateElement, deleteElement, elementCreated } from "@webiny/app-page-builder/editor/actions";
export default (function () {
  return {
    name: "pb-editor-page-element-block",
    type: "pb-editor-page-element",
    elementType: "block",
    settings: ["pb-editor-page-element-settings-background", "pb-editor-page-element-settings-animation", "", "pb-editor-page-element-settings-border", "pb-editor-page-element-settings-shadow", "", "pb-editor-page-element-settings-padding", "pb-editor-page-element-settings-margin", "pb-editor-page-element-settings-width", "pb-editor-page-element-settings-height", "pb-editor-page-element-settings-horizontal-align-flex", "pb-editor-page-element-settings-vertical-align", "", "pb-editor-page-element-settings-clone", "pb-editor-page-element-settings-delete", ""],
    create: function create() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return _objectSpread({
        type: "block",
        elements: [createRow({
          elements: [createColumn({
            data: {
              width: 100
            }
          })]
        })],
        data: {
          settings: {
            width: {
              value: "1000px"
            },
            margin: {
              mobile: {
                top: 15,
                left: 15,
                right: 15,
                bottom: 15
              },
              desktop: {
                top: 25,
                left: 0,
                right: 0,
                bottom: 25
              },
              advanced: true
            },
            padding: {
              mobile: {
                all: 10
              },
              desktop: {
                all: 0
              }
            }
          }
        }
      }, options);
    },
    render: function render(props) {
      return /*#__PURE__*/React.createElement(Block, props);
    },
    // This callback is executed when another element is dropped on the drop zones with type "block"
    onReceived: function onReceived(_ref) {
      var source = _ref.source,
          target = _ref.target,
          _ref$position = _ref.position,
          position = _ref$position === void 0 ? null : _ref$position;
      var dispatchNew = false;
      var element;

      if (source.path) {
        element = cloneElement(source);
      } else {
        dispatchNew = true;
        element = createElement(source.type, {}, target);
      }

      var block = addElementToParent(element, target, position); // Dispatch update action

      redux.store.dispatch(updateElement({
        element: block
      })); // Delete exiting element

      if (source.path) {
        redux.store.dispatch(deleteElement({
          element: source
        }));
      }

      if (dispatchNew) {
        redux.store.dispatch(elementCreated({
          element: element,
          source: source
        }));
      }
    },
    onChildDeleted: function onChildDeleted(_ref2) {
      var element = _ref2.element;

      if (element.elements.length === 0) {
        element = set(element, "elements", [createRow({
          elements: [createColumn({
            data: {
              width: 100
            }
          })]
        })]);
        redux.store.dispatch(updateElement({
          element: element
        }));
      }
    }
  };
});
//# sourceMappingURL=index.js.map