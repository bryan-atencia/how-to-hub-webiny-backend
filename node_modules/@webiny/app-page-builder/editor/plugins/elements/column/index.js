import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import React from "react";
import styled from "@emotion/styled";
import { set } from "dot-prop-immutable";
import { redux } from "@webiny/app-page-builder/editor/redux";
import Column from "./Column";
import { createElement, createColumn, cloneElement, addElementToParent } from "@webiny/app-page-builder/editor/utils";
import { updateElement, deleteElement, elementCreated } from "@webiny/app-page-builder/editor/actions";
import { getParentElementWithChildren } from "@webiny/app-page-builder/editor/selectors";
import { ReactComponent as ColumnIcon } from "@svgr/webpack!@webiny/app-page-builder/editor/assets/icons/column-icon.svg";
export default (function () {
  var PreviewBox = /*#__PURE__*/styled("div", {
    target: "ewq6cvp0",
    label: "PreviewBox"
  })({
    textAlign: "center",
    height: 50,
    svg: {
      height: 50,
      width: 50
    }
  });
  return {
    name: "pb-editor-page-element-column",
    type: "pb-editor-page-element",
    elementType: "column",
    toolbar: {
      title: "Column",
      group: "pb-editor-element-group-layout",
      preview: function preview() {
        return /*#__PURE__*/React.createElement(PreviewBox, null, /*#__PURE__*/React.createElement(ColumnIcon, null));
      }
    },
    settings: ["pb-editor-page-element-settings-background", "pb-editor-page-element-settings-animation", "", "pb-editor-page-element-settings-border", "pb-editor-page-element-settings-shadow", "", "pb-editor-page-element-settings-padding", "pb-editor-page-element-settings-margin", "pb-editor-page-element-settings-horizontal-align", "pb-editor-page-element-settings-vertical-align", "", "pb-editor-page-element-settings-clone", "pb-editor-page-element-settings-delete", ""],
    target: ["row"],
    create: function create() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return {
        type: "column",
        data: _objectSpread(_objectSpread({}, options.data || {}), {}, {
          settings: {
            margin: {
              desktop: {
                all: 0
              },
              mobile: {
                all: 0
              }
            },
            padding: {
              desktop: {
                all: 0
              },
              mobile: {
                all: 0
              }
            }
          }
        }),
        elements: options.elements || []
      };
    },
    render: function render(props) {
      return /*#__PURE__*/React.createElement(Column, props);
    },
    canDelete: function canDelete(_ref) {
      var element = _ref.element;
      var parent = getParentElementWithChildren(redux.store.getState(), element.id);
      return parent.elements.length > 1;
    },
    onReceived: function onReceived(_ref2) {
      var source = _ref2.source,
          target = _ref2.target,
          _ref2$position = _ref2.position,
          position = _ref2$position === void 0 ? null : _ref2$position;
      var droppedOnCenter = position === null; // Dropped a column onto a center drop zone

      if (source.type === "column" && droppedOnCenter) {
        return splitColumn(source, target);
      }

      handleDroppedElement(source, target, position);
    }
  };
});

var handleDroppedElement = function handleDroppedElement(source, target, position) {
  var dispatchNew = false;
  var element;

  if (source.path) {
    element = cloneElement(source);
  } else {
    dispatchNew = true;
    element = createElement(source.type, {}, target);
  }

  target = addElementToParent(element, target, position);
  redux.store.dispatch(updateElement({
    element: target
  }));

  if (source.path) {
    redux.store.dispatch(deleteElement({
      element: source
    }));
  }

  if (dispatchNew) {
    redux.store.dispatch(elementCreated({
      element: element,
      source: source
    }));
  }
};

var splitColumn = function splitColumn(source, target) {
  var dispatchNew = false;
  var row = getParentElementWithChildren(redux.store.getState(), target.id);
  var targetIndex = row.elements.findIndex(function (el) {
    return el.id === target.id;
  }); // Split target column in half

  row.elements[targetIndex].data.width /= 2; // Create a new column with half of the original target width

  var newColumn;

  if (source.path) {
    newColumn = cloneElement(source);
  } else {
    dispatchNew = true;
    newColumn = createColumn();
  }

  newColumn = set(newColumn, "data.width", row.elements[targetIndex].data.width);
  row = addElementToParent(newColumn, row, targetIndex + 1);
  redux.store.dispatch(updateElement({
    element: row
  }));

  if (source.path) {
    redux.store.dispatch(deleteElement({
      element: source
    }));
  }

  if (dispatchNew) {
    redux.store.dispatch(elementCreated({
      element: newColumn,
      source: source
    }));
  }
};
//# sourceMappingURL=index.js.map