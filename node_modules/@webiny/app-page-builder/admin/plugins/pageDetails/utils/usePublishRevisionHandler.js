import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import React from "react";
import { set } from "dot-prop-immutable";
import { useApolloClient } from "react-apollo";
import { useSnackbar } from "@webiny/app-admin/hooks/useSnackbar";
import { PUBLISH_REVISION, GET_PAGE } from "@webiny/app-page-builder/admin/graphql/pages";
export function usePublishRevisionHandler(_ref) {
  var page = _ref.page;
  var client = useApolloClient();

  var _useSnackbar = useSnackbar(),
      showSnackbar = _useSnackbar.showSnackbar;

  var publishRevision = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(revision) {
      var _yield$client$mutate, res, error;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return client.mutate({
                mutation: PUBLISH_REVISION,
                variables: {
                  id: revision.id
                },
                refetchQueries: ["PbListPages"],
                update: function update(cache, _ref3) {
                  var data = _ref3.data;

                  // Don't do anything if there was an error during publishing!
                  if (data.pageBuilder.publishRevision.error) {
                    return;
                  }

                  var getPageQuery = GET_PAGE(); // Update revisions

                  var pageFromCache = cache.readQuery({
                    query: getPageQuery,
                    variables: {
                      id: page.id
                    }
                  });
                  page.revisions.forEach(function (r) {
                    // Update published/locked fields on the revision that was just published.
                    if (r.id === revision.id) {
                      r.published = true;
                      r.locked = true;
                      return;
                    } // Unpublish other published revisions


                    if (r.published) {
                      r.published = false;
                    }
                  }); // Write our data back to the cache.

                  cache.writeQuery({
                    query: getPageQuery,
                    data: set(pageFromCache, "pageBuilder.page.data", page)
                  });
                }
              });

            case 2:
              _yield$client$mutate = _context.sent;
              res = _yield$client$mutate.data;
              error = res.pageBuilder.publishRevision.error;

              if (!error) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", showSnackbar(error.message));

            case 7:
              showSnackbar( /*#__PURE__*/React.createElement("span", null, "Successfully published revision ", /*#__PURE__*/React.createElement("strong", null, "#", revision.version), "!"));

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function publishRevision(_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  return {
    publishRevision: publishRevision
  };
}
//# sourceMappingURL=usePublishRevisionHandler.js.map