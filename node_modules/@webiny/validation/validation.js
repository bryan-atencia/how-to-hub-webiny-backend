"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _trim2 = _interopRequireDefault(require("lodash/trim"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _validationError = _interopRequireDefault(require("./validationError"));

const entries = validators => {
  return Object.entries(validators);
};

const invalidRules = "Validators must be specified as a string (eg. required,minLength:10,email).";
const createdValidators = {
  async: {},
  sync: {}
};
/**
 * Main class of Validation library.
 * Exported as a singleton instance, it offers methods for sync/async data validation and overwriting or adding new validators.
 *
 * @class Validation
 * @example
 * import { validation } from '@webiny/validation';
 *
 * // `validation` is a preconfigured instance of Validation class.
 * // From here you can either add new validators or use it as-is.
 */

class Validation {
  /**
   * Contains a list of all set validators.
   * @private
   */
  constructor() {
    (0, _defineProperty2.default)(this, "__validators", void 0);
    this.__validators = {};
  }
  /**
   * Add new validator.
   * @param name Validator name.
   * @param callable Validator function which throws a ValidationError if validation fails.
   * @returns {Validation}
   */


  setValidator(name, callable) {
    this.__validators[name] = callable;
    return this;
  }
  /**
   * Get validator function by name.
   * @param name Validator name.
   * @returns {Validator} A validator function.
   */


  getValidator(name) {
    if (!this.__validators[name]) {
      throw new _validationError.default("Validator `" + name + "` does not exist!", name);
    }

    return this.__validators[name];
  }
  /**
   * Asynchronously validates value.
   * @param value Value to validate.
   * @param validators A list of comma-separated validators (eg. required,number,gt:20).
   * @param [options] Validation options.
   * @returns {Promise<boolean | ValidationError>}
   */


  async validate(value, validators, options = {}) {
    if ((0, _isString2.default)(validators) && (0, _isEmpty2.default)(validators)) {
      return true;
    }

    if (!(0, _isString2.default)(validators)) {
      throw new Error(invalidRules);
    }

    const parsedValidateProperty = this.__parseValidateProperty(validators);

    for (const [name, params] of entries(parsedValidateProperty)) {
      const validator = this.getValidator(name);

      try {
        await validator(value, params);
      } catch (e) {
        const validationError = new _validationError.default(e.message, name, value);

        if (options.throw === false) {
          return validationError;
        }

        throw validationError;
      }
    }

    return true;
  }
  /**
   * Synchronously validates value.
   * @param value Value to validate.
   * @param validators A list of comma-separated validators (eg. required,number,gt:20).
   * @param [options] Validation options.
   * @returns {Promise<boolean | ValidationError>}
   */


  validateSync(value, validators, options = {}) {
    if ((0, _isString2.default)(validators) && (0, _isEmpty2.default)(validators)) {
      return true;
    }

    if (!(0, _isString2.default)(validators)) {
      throw new Error(invalidRules);
    }

    const parsedValidateProperty = this.__parseValidateProperty(validators);

    for (const [name, params] of entries(parsedValidateProperty)) {
      const validator = this.getValidator(name);

      try {
        validator(value, params);
      } catch (e) {
        const validationError = new _validationError.default(e.message, name, value);

        if (options.throw === false) {
          return validationError;
        }

        throw validationError;
      }
    }

    return true;
  }

  create(validators) {
    if (createdValidators.async[validators]) {
      return createdValidators.async[validators];
    }

    createdValidators.async[validators] = value => this.validate(value, validators);

    return createdValidators.async[validators];
  }

  createSync(validators) {
    if (createdValidators.sync[validators]) {
      return createdValidators.sync[validators];
    }

    createdValidators.sync[validators] = value => this.validateSync(value, validators);

    return createdValidators.sync[validators];
  }
  /**
   * Parses a string of validators with parameters.
   * @param validators A list of comma-separated validators (eg. required,number,gt:20).
   * @returns {ParsedValidators}
   * @private
   */


  __parseValidateProperty(validators) {
    const validate = validators.split(",");
    const parsedValidators = {};
    validate.forEach(v => {
      const params = (0, _trim2.default)(v).split(":");
      const vName = params.shift();
      parsedValidators[vName] = params;
    });
    return parsedValidators;
  }

}

var _default = Validation;
exports.default = _default;
//# sourceMappingURL=validation.js.map