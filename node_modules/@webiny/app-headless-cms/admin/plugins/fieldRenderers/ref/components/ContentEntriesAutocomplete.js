import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";

function _templateObject2() {
  var data = _taggedTemplateLiteral(["publish it"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["Selected content entry is not published. Make sure to {publishItLink} before publishing the main content entry."]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

import React, { useState, useMemo, useEffect } from "react";
import { AutoComplete } from "@webiny/ui/AutoComplete";
import { useQuery } from "@webiny/app-headless-cms/admin/hooks";
import get from "lodash/get";
import debounce from "lodash/debounce";
import { useI18N } from "@webiny/app-i18n/hooks/useI18N";
import { I18NValue } from "@webiny/app-i18n/components";
import { createListQuery, createGetQuery, GET_CONTENT_MODEL } from "./graphql";
import { i18n } from "@webiny/app/i18n";
import { Link } from "@webiny/react-router";
var t = i18n.ns("app-headless-cms/admin/fields/ref");

function ContentEntriesAutocomplete(_ref) {
  var bind = _ref.bind,
      field = _ref.field;
  // Value can be an object (received from API) or an ID (set by the Autocomplete component).
  var value = get(bind, "value.id", bind.value);

  var _useState = useState(""),
      _useState2 = _slicedToArray(_useState, 2),
      search = _useState2[0],
      setSearch = _useState2[1];

  var _useI18N = useI18N(),
      getValue = _useI18N.getValue; // Format value coming from API.


  useEffect(function () {
    if (typeof bind.value !== "string") {
      // We only need IDs to send back in request to API.
      bind.onChange(get(bind.value, "id", bind.value));
    }
  }, [bind.value]); // Fetch ref content model data, so that we can its title field.

  var refContentModelQuery = useQuery(GET_CONTENT_MODEL, {
    variables: {
      where: {
        modelId: field.settings.modelId
      }
    }
  });
  var refContentModel = get(refContentModelQuery, "data.getContentModel.data", {}); // Once we have the refContentModel loaded, this will construct proper list and get queries.

  var _useMemo = useMemo(function () {
    return {
      LIST_CONTENT: createListQuery(refContentModel),
      GET_CONTENT: createGetQuery(refContentModel)
    };
  }, [field.settings.modelId, refContentModel.id]),
      LIST_CONTENT = _useMemo.LIST_CONTENT,
      GET_CONTENT = _useMemo.GET_CONTENT; // Once the query in the input has changed, this query will be triggered.


  var titleFieldId = refContentModel.titleFieldId;
  var listContentQuery = useQuery(LIST_CONTENT, {
    skip: !search || !titleFieldId,
    variables: {
      where: _defineProperty({}, "".concat(titleFieldId, "_contains"), search)
    }
  }); // Once we have a valid ID, we load the data.

  var getContentQuery = useQuery(GET_CONTENT, {
    skip: !value || !titleFieldId,
    variables: {
      where: {
        id: value
      }
    }
  }); // Format options for the Autocomplete component.

  var options = get(listContentQuery, "data.content.data", []).map(function (item) {
    return {
      id: item.id,
      name: getValue(item.meta.title)
    };
  }); // Calculate a couple of props for the Autocomplete component.

  var id = get(getContentQuery, "data.content.data.id");
  var published = get(getContentQuery, "data.content.data.meta.published");
  var name = getValue(get(getContentQuery, "data.content.data.meta.title"));
  var loading = listContentQuery.loading || refContentModelQuery.loading || getContentQuery.loading;
  var unpublishedEntryInfo = published === false && t(_templateObject())({
    publishItLink: /*#__PURE__*/React.createElement(Link, {
      to: "/cms/content-models/manage/".concat(refContentModel.modelId, "?id=").concat(id)
    }, t(_templateObject2()))
  });
  return /*#__PURE__*/React.createElement(AutoComplete, Object.assign({}, bind, {
    loading: loading,
    value: {
      id: id,
      name: name
    },
    options: options,
    label: /*#__PURE__*/React.createElement(I18NValue, {
      value: field.label
    }),
    description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(I18NValue, {
      value: field.helpText
    }), unpublishedEntryInfo),
    onInput: debounce(function (search) {
      return search && setSearch(search);
    }, 250)
  }));
}

export default ContentEntriesAutocomplete;
//# sourceMappingURL=ContentEntriesAutocomplete.js.map