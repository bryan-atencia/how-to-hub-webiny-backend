import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";

function _templateObject() {
  var data = _taggedTemplateLiteral(["Before publishing the main content entry, make sure to publish the\n                            following referenced entries: {entries}"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

import React, { useEffect, useState, useMemo } from "react";
import { I18NValue } from "@webiny/app-i18n/components";
import { MultiAutoComplete } from "@webiny/ui/AutoComplete";
import { useQuery } from "@webiny/app-headless-cms/admin/hooks";
import { useI18N } from "@webiny/app-i18n/hooks/useI18N";
import get from "lodash/get";
import debounce from "lodash/debounce";
import { createListQuery, GET_CONTENT_MODEL } from "./graphql";
import { i18n } from "@webiny/app/i18n";
import { Link } from "@webiny/react-router";
var t = i18n.ns("app-headless-cms/admin/fields/ref");

function ContentEntriesMultiAutocomplete(_ref) {
  var bind = _ref.bind,
      field = _ref.field;
  // Value can be an array of object (received from API) or an array of ID (set by the Autocomplete component).
  var value = bind.value.map(function (item) {
    return get(item, "id", item);
  });

  var _useState = useState(""),
      _useState2 = _slicedToArray(_useState, 2),
      search = _useState2[0],
      setSearch = _useState2[1]; // Format value coming from API


  useEffect(function () {
    if (bind.value.some(function (v) {
      return typeof v !== "string";
    })) {
      // We only need IDs to send back in request to API
      bind.onChange(bind.value.map(function (item) {
        return get(item, "id", item);
      }));
    }
  }, [bind.value]);

  var _useI18N = useI18N(),
      getValue = _useI18N.getValue; // Fetch ref content model data, so that we can its title field.


  var refContentModelQuery = useQuery(GET_CONTENT_MODEL, {
    variables: {
      where: {
        modelId: field.settings.modelId
      }
    }
  });
  var refContentModel = get(refContentModelQuery, "data.getContentModel.data", {}); // Once we have the refContentModel loaded, this will construct proper list and get queries.

  var _useMemo = useMemo(function () {
    return {
      LIST_CONTENT: createListQuery(refContentModel)
    };
  }, [field.settings.modelId, refContentModel.id]),
      LIST_CONTENT = _useMemo.LIST_CONTENT; // Once the query in the input has changed, this query will be triggered.


  var titleFieldId = refContentModel.titleFieldId;
  var listContentQuery = useQuery(LIST_CONTENT, {
    skip: !search || !titleFieldId,
    variables: {
      where: _defineProperty({}, "".concat(titleFieldId, "_contains"), search)
    }
  }); // Once we have a valid IDs, we load the data.

  var listContentQueryFilterById = useQuery(LIST_CONTENT, {
    skip: !value || !titleFieldId,
    variables: {
      where: _defineProperty({}, "id_in", value)
    }
  }); // Format options for the Autocomplete component.

  var options = get(listContentQuery, "data.content.data", []).map(function (item) {
    return {
      id: item.id,
      name: getValue(item.meta.title)
    };
  }); // Format value prop for the Autocomplete component.

  var valueForAutoComplete = get(listContentQueryFilterById, "data.content.data", []).map(function (item) {
    return {
      id: item.id,
      published: item.meta.published,
      name: getValue(item.meta.title)
    };
  }); // Calculate loading prop for the Autocomplete component.

  var loading = listContentQuery.loading || refContentModelQuery.loading || listContentQueryFilterById.loading;
  var unpublishedEntriesInfo = valueForAutoComplete.filter(function (item) {
    return item.published === false;
  });

  if (unpublishedEntriesInfo.length) {
    unpublishedEntriesInfo = t(_templateObject())({
      entries: /*#__PURE__*/React.createElement(React.Fragment, null, unpublishedEntriesInfo.map(function (_ref2, index) {
        var id = _ref2.id,
            name = _ref2.name,
            published = _ref2.published;
        return !published && /*#__PURE__*/React.createElement(React.Fragment, {
          key: id
        }, index > 0 && ", ", /*#__PURE__*/React.createElement(Link, {
          to: "/cms/content-models/manage/".concat(refContentModel.modelId, "?id=").concat(id)
        }, name));
      }))
    });
  }

  return /*#__PURE__*/React.createElement(MultiAutoComplete, Object.assign({}, bind, {
    onChange: function onChange(values) {
      // We only need IDs to send back in request to API
      bind.onChange(values.map(function (item) {
        return get(item, "id", item);
      }));
    },
    loading: loading,
    value: valueForAutoComplete,
    options: options,
    label: /*#__PURE__*/React.createElement(I18NValue, {
      value: field.label
    }),
    onInput: debounce(function (search) {
      return search && setSearch(search);
    }, 250),
    description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(I18NValue, {
      value: field.helpText
    }), unpublishedEntriesInfo)
  }));
}

export default ContentEntriesMultiAutocomplete;
//# sourceMappingURL=ContentEntriesMultiAutoComplete.js.map