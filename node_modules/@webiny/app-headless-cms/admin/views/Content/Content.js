import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function _templateObject() {
  var data = _taggedTemplateLiteral(["Could not load content for \"{modelId}\" model. Redirecting..."]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

import React, { useMemo, useState } from "react";
import { SplitView, LeftPanel, RightPanel } from "@webiny/app-admin/components/SplitView";
import { useDataList } from "@webiny/app/hooks/useDataList";
import ContentDataList from "./ContentDataList";
import ContentDetails from "./ContentDetails";
import { createListQuery } from "@webiny/app-headless-cms/admin/components/ContentModelForm/graphql";
import get from "lodash.get";
import { useApolloClient, useQuery } from "@webiny/app-headless-cms/admin/hooks";
import { GET_CONTENT_MODEL_BY_MODEL_ID } from "./graphql";
import { FloatingActionButton } from "@webiny/app-admin/components/FloatingActionButton";
import { useRouter } from "@webiny/react-router";
import { useSnackbar } from "@webiny/app-admin/hooks/useSnackbar";
import { i18n } from "@webiny/app/i18n";
var t = i18n.ns("app-headless-cms/admin/content");

var ContentRender = function ContentRender(_ref) {
  var contentModel = _ref.contentModel;
  var apolloClient = useApolloClient();

  var _useRouter = useRouter(),
      history = _useRouter.history;

  var LIST_QUERY = useMemo(function () {
    return createListQuery(contentModel);
  }, [contentModel.modelId]);
  var query = new URLSearchParams(location.search);
  var variables = {};

  if (query.get("search")) {
    // We use the title field with the "contains" operator for doing basic searches.
    var searchField = contentModel.titleFieldId + "_contains";
    variables = {
      where: _defineProperty({}, searchField, query.get("search"))
    };
  }

  var dataList = useDataList({
    client: apolloClient,
    query: LIST_QUERY,
    variables: variables,
    getData: function getData(response) {
      return get(response, "content.data");
    },
    getMeta: function getMeta(response) {
      return get(response, "content.meta");
    },
    getError: function getError(response) {
      return get(response, "content.error");
    }
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SplitView, null, /*#__PURE__*/React.createElement(LeftPanel, {
    span: 4
  }, /*#__PURE__*/React.createElement(ContentDataList, {
    dataList: dataList,
    contentModel: contentModel
  })), /*#__PURE__*/React.createElement(RightPanel, {
    span: 8
  }, /*#__PURE__*/React.createElement(ContentDetails, {
    dataList: dataList,
    contentModel: contentModel
  }))), /*#__PURE__*/React.createElement(FloatingActionButton, {
    "data-testid": "new-record-button",
    onClick: function onClick() {
      var query = new URLSearchParams(location.search);
      query.delete("id");
      history.push({
        search: query.toString()
      });
    }
  }));
};

var Content = function Content() {
  var _useRouter2 = useRouter(),
      match = _useRouter2.match;

  var _useState = useState(),
      _useState2 = _slicedToArray(_useState, 2),
      contentModel = _useState2[0],
      setContentModel = _useState2[1];

  var _useRouter3 = useRouter(),
      history = _useRouter3.history;

  var modelId = get(match, "params.modelId");

  var _useSnackbar = useSnackbar(),
      showSnackbar = _useSnackbar.showSnackbar;

  useQuery(GET_CONTENT_MODEL_BY_MODEL_ID, {
    skip: !modelId,
    variables: {
      modelId: modelId
    },
    onCompleted: function onCompleted(data) {
      var contentModel = get(data, "getContentModel.data");

      if (contentModel) {
        return setContentModel(contentModel);
      }

      history.push("/cms/content-models");
      showSnackbar(t(_templateObject())({
        modelId: modelId
      }));
    }
  });

  if (!contentModel) {
    return null;
  } // Added "key" prop which somehow fixes the "Internal Error: may not update existing query string in store" error
  // that would occur when doing a search on a different content model (via the global search bar).
  // Didn't find what was actually causing the issue, nor the Google returned any results for the error above.


  return /*#__PURE__*/React.createElement(ContentRender, {
    contentModel: contentModel,
    key: contentModel.modelId
  });
};

export default Content;
//# sourceMappingURL=Content.js.map