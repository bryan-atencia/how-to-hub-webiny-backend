import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useReducer, useEffect, useCallback, useMemo } from "react";
import { useApolloClient } from "react-apollo";
import localStorage from "store";
import observe from "store/plugins/observe";
import { getPlugins } from "@webiny/plugins";
import { useHandler } from "@webiny/app/hooks/useHandler";
import { GET_CURRENT_USER, ID_TOKEN_LOGIN } from "../../components/graphql";
import { setIdentity } from "../../identity";
export var SecurityContext = React.createContext(null);
localStorage.addPlugin(observe);
export var DEFAULT_AUTH_TOKEN = "webiny-token";
export var SecurityConsumer = function SecurityConsumer(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/React.createElement(SecurityContext.Consumer, null, function (security) {
    return /*#__PURE__*/React.cloneElement(children, {
      security: security
    });
  });
};
export var SecurityProvider = function SecurityProvider(props) {
  var auth = getPlugins("security-authentication-provider").pop();

  if (!auth) {
    throw Error("You must register a \"security-authentication-provider\" plugin to use Security provider!");
  }

  var AUTH_TOKEN = props.AUTH_TOKEN || DEFAULT_AUTH_TOKEN;
  var client = useApolloClient();

  var _useReducer = useReducer(function (prev, next) {
    return _objectSpread(_objectSpread({}, prev), next);
  }, {
    user: null,
    firstLoad: true,
    loading: false,
    checkingUser: false
  }),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      state = _useReducer2[0],
      setState = _useReducer2[1];

  var getToken = useCallback(function () {
    return localStorage.get(AUTH_TOKEN);
  }, []);

  var loginUsingIdToken = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(idToken) {
      var res;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return client.mutate({
                mutation: ID_TOKEN_LOGIN,
                variables: {
                  idToken: idToken
                }
              });

            case 2:
              res = _context.sent;

              if (res.error) {
                _context.next = 5;
                break;
              }

              return _context.abrupt("return", res.data.security.loginUsingIdToken.data);

            case 5:
              return _context.abrupt("return", {
                user: null,
                token: null
              });

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function loginUsingIdToken(_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  var removeToken = useCallback(function () {
    localStorage.remove(AUTH_TOKEN);
  }, []);
  var setToken = useCallback(function (token) {
    return localStorage.set(AUTH_TOKEN, token);
  }, []);
  var getUser = useHandler(props, function (_ref3) {
    var getUser = _ref3.getUser;
    return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var _user, _yield$client$query, data;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              setState({
                loading: true
              });

              if (!getUser) {
                _context2.next = 7;
                break;
              }

              _context2.next = 4;
              return getUser();

            case 4:
              _user = _context2.sent;
              setState({
                loading: false
              });
              return _context2.abrupt("return", _user);

            case 7:
              _context2.next = 9;
              return client.query({
                query: GET_CURRENT_USER,
                fetchPolicy: "no-cache"
              });

            case 9:
              _yield$client$query = _context2.sent;
              data = _yield$client$query.data;
              setState({
                loading: false
              });
              return _context2.abrupt("return", data.security.getCurrentUser.data);

            case 13:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
  });
  /**
   * Should be called only by authentication plugin when it obtains
   * an `idToken` from the authentication provider.
   */

  var onIdToken = useHandler(null, function () {
    return /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(idToken) {
        var _yield$loginUsingIdTo, token, user;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                setState({
                  checkingUser: true
                });
                _context3.next = 3;
                return loginUsingIdToken(idToken);

              case 3:
                _yield$loginUsingIdTo = _context3.sent;
                token = _yield$loginUsingIdTo.token;
                user = _yield$loginUsingIdTo.user;
                setIdentity(user);
                setToken(token);
                setState({
                  user: user,
                  checkingUser: false
                });
                props.onUser && props.onUser(user);

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x2) {
        return _ref5.apply(this, arguments);
      };
    }();
  }); // Run authentication plugin hook

  var _auth$securityProvide = auth.securityProviderHook({
    onIdToken: onIdToken
  }),
      getIdToken = _auth$securityProvide.getIdToken,
      renderAuthentication = _auth$securityProvide.renderAuthentication,
      authLogout = _auth$securityProvide.logout;

  var logout = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return authLogout();

          case 2:
            localStorage.remove(AUTH_TOKEN);

          case 3:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  })), []);
  /**
   * Check if user is logged-in and update state accordingly.
   */

  var checkUser = useHandler(null, function () {
    return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
      var idToken, _yield$loginUsingIdTo2, token, _user2, user;

      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return getIdToken();

            case 2:
              idToken = _context5.sent;

              if (idToken) {
                _context5.next = 7;
                break;
              }

              removeToken();
              setState({
                checkingUser: false,
                user: null
              });
              return _context5.abrupt("return");

            case 7:
              if (getToken()) {
                _context5.next = 15;
                break;
              }

              _context5.next = 10;
              return loginUsingIdToken(idToken);

            case 10:
              _yield$loginUsingIdTo2 = _context5.sent;
              token = _yield$loginUsingIdTo2.token;
              _user2 = _yield$loginUsingIdTo2.user;

              if (token) {
                setIdentity(_user2);
                setToken(token);
                setState({
                  user: _user2,
                  checkingUser: false
                });
              }

              return _context5.abrupt("return");

            case 15:
              // Try loading user data using Webiny token
              setState({
                checkingUser: true
              });
              _context5.next = 18;
              return getUser();

            case 18:
              user = _context5.sent;
              setState({
                checkingUser: false
              });

              if (!user) {
                _context5.next = 26;
                break;
              }

              setIdentity(user);
              setState({
                user: user
              });
              props.onUser && props.onUser(user);
              _context5.next = 29;
              break;

            case 26:
              removeToken();
              _context5.next = 29;
              return checkUser();

            case 29:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
  });
  var value = useMemo(function () {
    return {
      user: state.user,
      logout: logout,
      renderAuthentication: renderAuthentication,
      refreshUser: function () {
        var _refreshUser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
          var user;
          return _regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return getUser();

                case 2:
                  user = _context6.sent;

                  if (!user) {
                    _context6.next = 8;
                    break;
                  }

                  setIdentity(user);
                  setState({
                    user: user
                  });
                  _context6.next = 11;
                  break;

                case 8:
                  removeToken();
                  _context6.next = 11;
                  return checkUser();

                case 11:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        function refreshUser() {
          return _refreshUser.apply(this, arguments);
        }

        return refreshUser;
      }()
    };
  }, [state.user]);
  useEffect(function () {
    localStorage.observe(AUTH_TOKEN, /*#__PURE__*/function () {
      var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(token) {
        var user;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (token) {
                  _context7.next = 3;
                  break;
                }

                setIdentity(null);
                return _context7.abrupt("return", setState({
                  user: null
                }));

              case 3:
                _context7.next = 5;
                return getUser();

              case 5:
                user = _context7.sent;
                setIdentity(user);
                setState({
                  user: user,
                  firstLoad: false
                });

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      return function (_x3) {
        return _ref8.apply(this, arguments);
      };
    }());
    checkUser();
  }, []);

  if (state.checkingUser) {
    return props.loader || null;
  }

  if (!state.user && !props.allowAnonymous) {
    return renderAuthentication();
  }

  return /*#__PURE__*/React.createElement(SecurityContext.Provider, {
    value: value
  }, props.children);
};
SecurityProvider.defaultProps = {
  allowAnonymous: false
};
//# sourceMappingURL=Security.js.map