import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _createSuper from "@babel/runtime/helpers/createSuper";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _isFunction from "lodash/isFunction";
import _keys from "lodash/keys";
import _isNil from "lodash/isNil";
import _get from "lodash/get";
import _has from "lodash/has";
import _each from "lodash/each";
import _isPlainObject from "lodash/isPlainObject";
import _cloneDeep from "lodash/cloneDeep";
import _isEqual from "lodash/isEqual";
import * as React from "react";
import set from "lodash/fp/set";
import { createBind } from "./Bind";
import { linkState } from "./linkState";
import ValidationError from "./ValidationError";
export var Form = /*#__PURE__*/function (_React$Component) {
  _inherits(Form, _React$Component);

  var _super = _createSuper(Form);

  function Form() {
    var _this;

    _classCallCheck(this, Form);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      data: _this.props.data || {},
      originalData: _this.props.data || {},
      wasSubmitted: false,
      validation: {}
    });

    _defineProperty(_assertThisInitialized(_this), "isValid", null);

    _defineProperty(_assertThisInitialized(_this), "inputs", {});

    _defineProperty(_assertThisInitialized(_this), "lastRender", []);

    _defineProperty(_assertThisInitialized(_this), "validateFns", {});

    _defineProperty(_assertThisInitialized(_this), "onChangeFns", {});

    _defineProperty(_assertThisInitialized(_this), "Bind", createBind(_assertThisInitialized(_this)));

    _defineProperty(_assertThisInitialized(_this), "onInvalid", function () {
      if (typeof _this.props.onInvalid === "function") {
        _this.props.onInvalid();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "submit", function (event) {
      // If event is present - prevent default behaviour
      if (event && event.preventDefault) {
        event.preventDefault();
      }

      _this.setState({
        wasSubmitted: true
      });

      return _this.validate().then(function (valid) {
        if (valid) {
          var _data = _this.state.data; // Make sure all current inputs have a value in the model (defaultValues do not exist in form data)

          var inputNames = Object.keys(_this.inputs);
          inputNames.forEach(function (name) {
            var defaultValue = _this.inputs[name].defaultValue;

            if (!_has(_data, name) && typeof defaultValue !== "undefined") {
              _data = set(name, defaultValue, _data);
            }
          });

          if (_this.props.onSubmit) {
            return _this.props.onSubmit(_data, _assertThisInitialized(_this));
          }

          return;
        }

        return _this.onInvalid();
      });
    });

    _defineProperty(_assertThisInitialized(_this), "validate", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var allIsValid, inputNames, i, _name, validators, hasValue, isInputValid, shouldValidate, validationResult;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              allIsValid = true; // Inputs must be validated in a queue because we may have async validators

              inputNames = Object.keys(_this.inputs);
              i = 0;

            case 3:
              if (!(i < inputNames.length)) {
                _context.next = 20;
                break;
              }

              _name = inputNames[i];
              validators = _this.inputs[_name].validators;

              if (validators) {
                _context.next = 8;
                break;
              }

              return _context.abrupt("continue", 17);

            case 8:
              hasValue = !!_get(_this.state.data, _name);
              isInputValid = _get(_this.state.validation[_name], "isValid");
              shouldValidate = !hasValue || hasValue && isInputValid !== true;

              if (!shouldValidate) {
                _context.next = 17;
                break;
              }

              if (!(isInputValid === false || _isNil(isInputValid))) {
                _context.next = 17;
                break;
              }

              _context.next = 15;
              return _this.validateInput(_name);

            case 15:
              validationResult = _context.sent;

              if (validationResult === false) {
                allIsValid = false;
              }

            case 17:
              i++;
              _context.next = 3;
              break;

            case 20:
              return _context.abrupt("return", allIsValid);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));

    _defineProperty(_assertThisInitialized(_this), "validateInput", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name) {
        var value, validators, hasValidators, formData;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return new Promise(function (res) {
                  return setTimeout(res, 10);
                });

              case 2:
                if (!(_this.props.validateOnFirstSubmit && !_this.state.wasSubmitted || !_this.inputs[name])) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return", Promise.resolve(null));

              case 4:
                value = _get(_this.state.data, name, _this.inputs[name].defaultValue);
                validators = _this.inputs[name].validators;
                hasValidators = _keys(validators).length; // Validate input

                formData = {
                  inputs: _this.inputs,
                  data: _objectSpread({}, _this.state.data)
                };

                _this.setState(function (state) {
                  return _objectSpread(_objectSpread({}, state), {}, {
                    validation: _objectSpread(_objectSpread({}, state.validation), {}, _defineProperty({}, name, _objectSpread(_objectSpread({}, state.validation[name]), {}, {
                      isValidating: true
                    })))
                  });
                });

                return _context2.abrupt("return", Promise.resolve(Form.executeValidators(value, validators, formData)).then(function (validationResults) {
                  var isValid = hasValidators ? value === null ? null : true : null;

                  _this.setState(function (state) {
                    return _objectSpread(_objectSpread({}, state), {}, {
                      validation: _objectSpread(_objectSpread({}, state.validation), {}, _defineProperty({}, name, {
                        isValid: isValid,
                        message: null,
                        results: validationResults
                      }))
                    });
                  });

                  return validationResults;
                }).catch(function (validationError) {
                  // Set component state to reflect validation error
                  _this.setState(function (state) {
                    return _objectSpread(_objectSpread({}, state), {}, {
                      validation: _objectSpread(_objectSpread({}, state.validation), {}, _defineProperty({}, name, {
                        isValid: false,
                        message: validationError.getMessage(),
                        results: false
                      }))
                    });
                  });

                  return false;
                }));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());

    _defineProperty(_assertThisInitialized(_this), "getOnChangeFn", function (_ref3) {
      var name = _ref3.name,
          beforeChange = _ref3.beforeChange,
          afterChange = _ref3.afterChange;

      if (!_this.onChangeFns[name]) {
        var linkStateChange = linkState(_assertThisInitialized(_this), "data.".concat(name));

        var baseOnChange = function baseOnChange(newValue, cb) {
          // When linkState is done processing the value change...
          return linkStateChange(newValue, cb).then(function (value) {
            // call the Form onChange with updated data
            if (typeof _this.props.onChange === "function") {
              _this.props.onChange(_objectSpread({}, _this.state.data), _assertThisInitialized(_this));
            } // Execute onAfterChange


            afterChange && afterChange(value);
            return value;
          });
        };

        var onChange = beforeChange ? function (newValue) {
          return beforeChange(newValue, baseOnChange);
        } : baseOnChange;
        _this.onChangeFns[name] = onChange;
      }

      return _this.onChangeFns[name];
    });

    _defineProperty(_assertThisInitialized(_this), "getValidateFn", function (name) {
      if (!_this.validateFns[name]) {
        _this.validateFns[name] = function () {
          return _this.validateInput(name);
        };
      }

      return _this.validateFns[name];
    });

    _defineProperty(_assertThisInitialized(_this), "__setValue", function (name, value) {
      _this.onChangeFns[name](value);
    });

    _defineProperty(_assertThisInitialized(_this), "__onKeyDown", function (e) {
      var _this$props$submitOnE = _this.props.submitOnEnter,
          submitOnEnter = _this$props$submitOnE === void 0 ? false : _this$props$submitOnE;

      if ((submitOnEnter || e.metaKey || e.ctrlKey) && e.key === "Enter" && !e.isDefaultPrevented()) {
        // Need to blur current target in case of input fields to trigger validation
        // @ts-ignore
        e.target && e.target.blur();
        e.preventDefault();
        e.stopPropagation(); // Fire submit with a small delay to allow input validation to complete.
        // Not an ideal solution but works fine at this point. Will revisit this later.

        setTimeout(function () {
          return _this.submit();
        }, 100);
      }
    });

    return _this;
  }

  _createClass(Form, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this2 = this;

      Object.keys(this.inputs).forEach(function (name) {
        if (!_this2.lastRender.includes(name)) {
          delete _this2.inputs[name];

          _this2.setState(function (state) {
            var validation = _objectSpread({}, state.validation);

            delete validation[name];
            return {
              validation: validation
            };
          });
        }
      });
    }
  }, {
    key: "render",
    value: function render() {
      var children = this.props.children;

      if (!_isFunction(children)) {
        throw new Error("Form must have a function as its only child!");
      }

      this.lastRender = [];
      return /*#__PURE__*/React.createElement("webiny-form-container", {
        onKeyDown: this.__onKeyDown
      }, children({
        data: _cloneDeep(this.state.data),
        setValue: this.__setValue,
        form: this,
        submit: this.submit,
        Bind: this.Bind
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(_ref4, state) {
      var data = _ref4.data,
          _ref4$invalidFields = _ref4.invalidFields,
          invalidFields = _ref4$invalidFields === void 0 ? {} : _ref4$invalidFields;

      // If we received new `data`, overwrite current `data` in the state
      if (!_isEqual(state.originalData, data)) {
        return {
          data: data,
          originalData: data,
          validation: {}
        };
      } // Check for validation errors


      var validation = _cloneDeep(state.validation);

      if (_isPlainObject(invalidFields) && Object.keys(invalidFields).length) {
        _each(invalidFields, function (message, name) {
          validation = _objectSpread(_objectSpread({}, validation), {}, _defineProperty({}, name, {
            isValid: false,
            message: message
          }));
        });
      } // Return new state only if something has changed


      return !_isEqual(validation, state.validation) ? {
        validation: validation
      } : null;
    }
  }]);

  return Form;
}(React.Component);

_defineProperty(Form, "defaultProps", {
  data: {},
  disabled: false,
  validateOnFirstSubmit: false,
  onSubmit: null
});

_defineProperty(Form, "executeValidators", /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(value, validators) {
    var formData,
        results,
        _loop,
        i,
        _args4 = arguments;

    return _regeneratorRuntime.wrap(function _callee3$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            formData = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
            validators = Array.isArray(validators) ? _toConsumableArray(validators) : [validators];
            results = {};
            _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop(i) {
              var validator;
              return _regeneratorRuntime.wrap(function _loop$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      validator = validators[i];
                      _context3.prev = 1;
                      _context3.next = 4;
                      return Promise.resolve(validator(value, formData)).then(function (result) {
                        if (result instanceof Error) {
                          throw result;
                        }

                        results[i] = result;
                      }).catch(function (e) {
                        throw new ValidationError(e.message, value);
                      });

                    case 4:
                      _context3.next = 9;
                      break;

                    case 6:
                      _context3.prev = 6;
                      _context3.t0 = _context3["catch"](1);
                      throw new ValidationError(_context3.t0.message, value);

                    case 9:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _loop, null, [[1, 6]]);
            });
            i = 0;

          case 5:
            if (!(i < validators.length)) {
              _context4.next = 10;
              break;
            }

            return _context4.delegateYield(_loop(i), "t0", 7);

          case 7:
            i++;
            _context4.next = 5;
            break;

          case 10:
            return _context4.abrupt("return", results);

          case 11:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee3);
  }));

  return function (_x2, _x3) {
    return _ref5.apply(this, arguments);
  };
}());
//# sourceMappingURL=Form.js.map