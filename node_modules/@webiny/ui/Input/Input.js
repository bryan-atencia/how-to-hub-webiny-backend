import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _createSuper from "@babel/runtime/helpers/createSuper";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import * as React from "react";
import { TextField } from "@rmwc/textfield";
import { FormElementMessage } from "@webiny/ui/FormElementMessage";
import pick from "lodash/pick";

/**
 * Use Input component to store short string values, like first name, last name, e-mail etc.
 * Additionally, with rows prop, it can also be turned into a text area, to store longer strings.
 */
export var Input = /*#__PURE__*/function (_React$Component) {
  _inherits(Input, _React$Component);

  var _super = _createSuper(Input);

  function Input() {
    var _this;

    _classCallCheck(this, Input);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "onChange", function (e) {
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          rawOnChange = _this$props.rawOnChange;

      if (!onChange) {
        return;
      } // @ts-ignore


      onChange(rawOnChange ? e : e.target.value);
    });

    _defineProperty(_assertThisInitialized(_this), "onBlur", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(e) {
        var _this$props2, validate, onBlur;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this$props2 = _this.props, validate = _this$props2.validate, onBlur = _this$props2.onBlur;

                if (!validate) {
                  _context.next = 5;
                  break;
                }

                // Since we are accessing event in an async operation, we need to persist it.
                // See https://reactjs.org/docs/events.html#event-pooling.
                e.persist();
                _context.next = 5;
                return validate();

              case 5:
                onBlur && onBlur(e);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());

    return _this;
  }

  _createClass(Input, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          autoFocus = _this$props3.autoFocus,
          value = _this$props3.value,
          label = _this$props3.label,
          description = _this$props3.description,
          placeholder = _this$props3.placeholder,
          rows = _this$props3.rows,
          validation = _this$props3.validation,
          icon = _this$props3.icon,
          trailingIcon = _this$props3.trailingIcon,
          onEnter = _this$props3.onEnter,
          props = _objectWithoutProperties(_this$props3, ["autoFocus", "value", "label", "description", "placeholder", "rows", "validation", "icon", "trailingIcon", "onEnter"]);

      var inputValue = value;

      if (value === null || typeof value === "undefined") {
        inputValue = "";
      }

      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TextField, Object.assign({}, pick(props, Input.rmwcProps), {
        onKeyDown: function onKeyDown(e) {
          if (typeof onEnter === "function" && e.key === "Enter") {
            onEnter();
          }

          if (typeof props.onKeyDown === "function") {
            for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              rest[_key2 - 1] = arguments[_key2];
            }

            return props.onKeyDown.apply(props, [e].concat(rest));
          }
        },
        autoFocus: autoFocus,
        textarea: Boolean(rows),
        value: inputValue,
        onChange: this.onChange,
        onBlur: this.onBlur,
        label: label,
        icon: icon,
        placeholder: !label && placeholder || undefined,
        trailingIcon: trailingIcon,
        rows: this.props.rows
      })), validation.isValid === false && /*#__PURE__*/React.createElement(FormElementMessage, {
        error: true
      }, validation.message), validation.isValid !== false && description && /*#__PURE__*/React.createElement(FormElementMessage, null, description));
    }
  }]);

  return Input;
}(React.Component);

_defineProperty(Input, "defaultProps", {
  rawOnChange: false,
  validation: {
    isValid: null,
    message: null
  }
});

_defineProperty(Input, "rmwcProps", ["label", "type", "step", "disabled", "placeholder", "outlined", "onKeyDown", "onKeyPress", "onKeyUp", "onFocus", "rootProps", "fullwidth", "inputRef", "className", "maxLength", "characterCount"]);
//# sourceMappingURL=Input.js.map