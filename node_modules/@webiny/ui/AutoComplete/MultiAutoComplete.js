import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _createSuper from "@babel/runtime/helpers/createSuper";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import * as React from "react";
import Downshift from "downshift";
import MaterialSpinner from "react-spinner-material";
import { Input } from "@webiny/ui/Input";
import { Chips, Chip } from "@webiny/ui/Chips";
import { getOptionValue, getOptionText } from "./utils";
import { ReactComponent as BaselineCloseIcon } from "@svgr/webpack!./icons/baseline-close-24px.svg";
import classNames from "classnames";
import { Elevation } from "@webiny/ui/Elevation";
import { Typography } from "@webiny/ui/Typography";
import { autoCompleteStyle, suggestionList } from "./styles";

function Spinner() {
  if (process.env.REACT_APP_ENV === "ssr") {
    return null;
  }

  return /*#__PURE__*/React.createElement(MaterialSpinner, {
    size: 24,
    spinnerColor: "#fa5723",
    spinnerWidth: 2,
    visible: true
  });
}

export var MultiAutoComplete = /*#__PURE__*/function (_React$Component) {
  _inherits(MultiAutoComplete, _React$Component);

  var _super = _createSuper(MultiAutoComplete);

  function MultiAutoComplete() {
    var _this;

    _classCallCheck(this, MultiAutoComplete);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      inputValue: ""
    });

    _defineProperty(_assertThisInitialized(_this), "downshift", /*#__PURE__*/React.createRef());

    _defineProperty(_assertThisInitialized(_this), "assignedValueAfterClearing", {
      set: false,
      selection: null
    });

    return _this;
  }

  _createClass(MultiAutoComplete, [{
    key: "getOptions",
    value: function getOptions() {
      var _this2 = this;

      var _this$props = this.props,
          unique = _this$props.unique,
          value = _this$props.value,
          allowFreeInput = _this$props.allowFreeInput,
          useSimpleValues = _this$props.useSimpleValues,
          options = _this$props.options;
      var filtered = options.filter(function (item) {
        // We need to filter received options.
        // 1) If "unique" prop was passed, we don't want to show already picked options again.
        if (unique) {
          var values = value;

          if (Array.isArray(values)) {
            if (values.find(function (value) {
              return getOptionValue(value, _this2.props) === getOptionValue(item, _this2.props);
            })) {
              return false;
            }
          }
        } // 2) At the end, we want to show only options that are matched by typed text.


        if (!_this2.state.inputValue) {
          return true;
        }

        return getOptionText(item, _this2.props).toLowerCase().includes(_this2.state.inputValue.toLowerCase());
      }); // If free input is allowed, prepend typed value to the list.

      if (allowFreeInput && this.state.inputValue) {
        if (useSimpleValues) {
          var existingValue = filtered.includes(this.state.inputValue);

          if (!existingValue) {
            filtered.unshift(this.state.inputValue);
          }
        } else {
          var _existingValue = filtered.find(function (item) {
            return _this2.state.inputValue === getOptionText(item, _this2.props);
          });

          if (!_existingValue) {
            filtered.unshift(_defineProperty({}, this.props.textProp, this.state.inputValue));
          }
        }
      }

      return filtered;
    }
    /**
     * Renders options - based on user's input. It will try to match input text with available options.
     * @param options
     * @param isOpen
     * @param highlightedIndex
     * @param selectedItem
     * @param getMenuProps
     * @param getItemProps
     * @returns {*}
     */

  }, {
    key: "renderOptions",
    value: function renderOptions(_ref) {
      var _this3 = this;

      var options = _ref.options,
          isOpen = _ref.isOpen,
          highlightedIndex = _ref.highlightedIndex,
          getMenuProps = _ref.getMenuProps,
          getItemProps = _ref.getItemProps;

      if (!isOpen) {
        return null;
      }

      if (!options.length) {
        return /*#__PURE__*/React.createElement(Elevation, {
          z: 1
        }, /*#__PURE__*/React.createElement("ul", getMenuProps(), /*#__PURE__*/React.createElement("li", null, /*#__PURE__*/React.createElement(Typography, {
          use: "body2"
        }, "No results."))));
      }

      var renderItem = this.props.renderItem;
      return /*#__PURE__*/React.createElement(Elevation, {
        z: 1
      }, /*#__PURE__*/React.createElement("ul", getMenuProps(), options.map(function (item, index) {
        var _itemClassNames;

        var itemValue = getOptionValue(item, _this3.props); // Base classes.

        var itemClassNames = (_itemClassNames = {}, _defineProperty(_itemClassNames, suggestionList, true), _defineProperty(_itemClassNames, "highlighted", highlightedIndex === index), _defineProperty(_itemClassNames, "selected", false), _itemClassNames); // Render the item.

        return /*#__PURE__*/React.createElement("li", Object.assign({
          key: itemValue + index
        }, getItemProps({
          index: index,
          item: item,
          className: classNames(itemClassNames)
        })), renderItem.call(_this3, item, index));
      })));
    }
    /**
     * Once added, items can also be removed by clicking on the âœ• icon. This is the method that is responsible for
     * rendering selected items (we are using already existing "Chips" component).
     * @returns {*}
     */

  }, {
    key: "renderMultipleSelection",
    value: function renderMultipleSelection() {
      var _this4 = this;

      var _this$props2 = this.props,
          value = _this$props2.value,
          onChange = _this$props2.onChange,
          disabled = _this$props2.disabled;
      return /*#__PURE__*/React.createElement(React.Fragment, null, Array.isArray(value) && value.length ? /*#__PURE__*/React.createElement(Chips, {
        disabled: disabled
      }, value.map(function (item, index) {
        return /*#__PURE__*/React.createElement(Chip, {
          label: getOptionText(item, _this4.props),
          key: "".concat(getOptionValue(item, _this4.props), "-").concat(index),
          trailingIcon: /*#__PURE__*/React.createElement(BaselineCloseIcon, null),
          onRemove: function onRemove() {
            // On removal, let's update the value and call "onChange" callback.
            if (onChange) {
              var newValue = _toConsumableArray(value);

              newValue.splice(index, 1);
              onChange(newValue);
            }
          }
        });
      })) : null);
    }
  }, {
    key: "render",
    value: function render() {
      var _this5 = this;

      var props = this.props,
          _this$props3 = this.props,
          rawOptions = _this$props3.options,
          allowFreeInput = _this$props3.allowFreeInput,
          useSimpleValues = _this$props3.useSimpleValues,
          unique = _this$props3.unique,
          value = _this$props3.value,
          _onChange = _this$props3.onChange,
          valueProp = _this$props3.valueProp,
          textProp = _this$props3.textProp,
          onInput = _this$props3.onInput,
          _this$props3$validati = _this$props3.validation,
          validation = _this$props3$validati === void 0 ? {
        isValid: null
      } : _this$props3$validati,
          otherInputProps = _objectWithoutProperties(_this$props3, ["options", "allowFreeInput", "useSimpleValues", "unique", "value", "onChange", "valueProp", "textProp", "onInput", "validation"]);

      var options = this.getOptions();
      return /*#__PURE__*/React.createElement("div", {
        className: autoCompleteStyle
      }, /*#__PURE__*/React.createElement(Downshift, {
        defaultSelectedItem: null // @ts-ignore
        ,
        className: autoCompleteStyle,
        itemToString: function itemToString(item) {
          return item && getOptionText(item, props);
        },
        ref: this.downshift,
        onChange: function onChange(selection) {
          if (!_this5.assignedValueAfterClearing.set) {
            _this5.assignedValueAfterClearing = {
              set: true,
              selection: selection
            };

            _this5.downshift.current.clearSelection();

            return;
          }

          if (_this5.assignedValueAfterClearing.set) {
            _this5.assignedValueAfterClearing.set = false;

            if (Array.isArray(value)) {
              _onChange && _onChange([].concat(_toConsumableArray(value), [_this5.assignedValueAfterClearing.selection]));
            } else {
              _onChange && _onChange([_this5.assignedValueAfterClearing.selection]);
            }
          }
        }
      }, function (_ref2) {
        var getInputProps = _ref2.getInputProps,
            openMenu = _ref2.openMenu,
            rest = _objectWithoutProperties(_ref2, ["getInputProps", "openMenu"]);

        return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Input, getInputProps(_objectSpread(_objectSpread({}, otherInputProps), {}, {
          // @ts-ignore
          validation: validation,
          rawOnChange: true,
          trailingIcon: _this5.props.loading && /*#__PURE__*/React.createElement(Spinner, null),
          onChange: function onChange(e) {
            return e;
          },
          onBlur: function onBlur(e) {
            return e;
          },
          onKeyUp: function onKeyUp(e) {
            var inputValue = e.target.value || ""; // Set current input value into state and trigger onInput if different.

            if (inputValue !== _this5.state.inputValue) {
              _this5.setState({
                inputValue: inputValue
              }, function () {
                onInput && onInput(inputValue);
              });
            }
          },
          onFocus: function onFocus(e) {
            openMenu();
            otherInputProps.onFocus && otherInputProps.onFocus(e);
          }
        }))), _this5.renderOptions(_objectSpread(_objectSpread({}, rest), {}, {
          unique: unique,
          options: options
        })), _this5.renderMultipleSelection());
      }));
    }
  }]);

  return MultiAutoComplete;
}(React.Component);

_defineProperty(MultiAutoComplete, "defaultProps", {
  valueProp: "id",
  textProp: "name",
  unique: true,
  options: [],
  useSimpleValues: false,
  renderItem: function renderItem(item) {
    return /*#__PURE__*/React.createElement(Typography, {
      use: "body2"
    }, getOptionText(item, this.props));
  }
});
//# sourceMappingURL=MultiAutoComplete.js.map