import _objectSpread from "@babel/runtime/helpers/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _createSuper from "@babel/runtime/helpers/createSuper";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import * as React from "react";
import { set } from "dot-prop-immutable";
import { useRouter } from "@webiny/react-router";
import Downshift from "downshift";
import { getPlugins } from "@webiny/plugins";
import classnames from "classnames";
import { Hotkeys } from "react-hotkeyz"; // UI components

import { Icon } from "@webiny/ui/Icon";
import { Elevation } from "@webiny/ui/Elevation";
import SearchBarDropdown from "./SearchBarDropdown"; // Icons

import { ReactComponent as SearchIcon } from "@svgr/webpack!./icons/round-search-24px.svg"; // Local components

import { SearchBarWrapper, SearchBarInputWrapper, SearchShortcut, searchBarInput, icon, searchWrapper } from "./styled";

var SearchBar = /*#__PURE__*/function (_React$Component) {
  _inherits(SearchBar, _React$Component);

  var _super = _createSuper(SearchBar);

  /**
   * Helps us trigger some of the downshift's methods (eg. clearSelection) and helps us to avoid adding state.
   */

  /**
   * At some point we must programmatically focus the input.
   */

  /**
   * Let's check if current route is defined in one of the registered plugins.
   * If so, then check current route query for search term and set it as default value of search input.
   * @param props
   */
  function SearchBar(props) {
    var _this;

    _classCallCheck(this, SearchBar);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "state", {
      active: false,
      searchTerm: {
        previous: "",
        current: ""
      },
      plugins: {
        // List of all registered "admin-global-search" plugins.
        get list() {
          return getPlugins("admin-global-search");
        },

        hotKeys: getPlugins("admin-global-search-prevent-hotkey"),
        // Current plugin - set by examining current route and its query params (on construct).
        current: undefined
      }
    });

    _defineProperty(_assertThisInitialized(_this), "downshift", /*#__PURE__*/React.createRef());

    _defineProperty(_assertThisInitialized(_this), "input", /*#__PURE__*/React.createRef());

    _defineProperty(_assertThisInitialized(_this), "handleOpenHotkey", function (e) {
      for (var i = 0; i < _this.state.plugins.hotKeys.length; i++) {
        var hotKey = _this.state.plugins.hotKeys[i];

        if (hotKey.preventOpen(e)) {
          return;
        }
      }

      e.preventDefault();

      _this.input.current.focus();
    });

    _defineProperty(_assertThisInitialized(_this), "submitSearchTerm", function (plugin) {
      _this.setState(function (state) {
        var newState = set(state, "searchTerm.previous", state.searchTerm.current);
        return set(newState, "plugins.current", plugin);
      }, function () {
        var query = new URLSearchParams();

        if (_this.state.searchTerm.current) {
          // If "search" key in the plugin was defined, it means SearchInput values were set. Otherwise,
          // we need to send the plain string into the "search" query param. This behavior was needed
          // eg. for pages, since Page entity doesn't use regular SearchInput type, but plain string.
          if (plugin.search) {
            query.set("search", JSON.stringify(_objectSpread({
              query: _this.state.searchTerm.current
            }, plugin.search)));
          } else {
            query.set("search", _this.state.searchTerm.current);
          }
        }

        _this.props.history.push({
          pathname: plugin.route,
          search: query.toString()
        });
      });
    });

    _defineProperty(_assertThisInitialized(_this), "cancelSearchTerm", function () {
      _this.setState(function (state) {
        state.searchTerm.current = state.searchTerm.previous;
        return state;
      });
    });

    _this.state.plugins.current = _this.state.plugins.list.find(function (p) {
      return p.route === props.location.pathname;
    });

    if (_this.state.plugins.current) {
      var search;
      var query = new URLSearchParams(props.location.search);

      try {
        search = JSON.parse(query.get("search") || "").query;
      } catch (e) {
        search = query.get("search");
      }

      _this.state.searchTerm.current = search || "";
      _this.state.searchTerm.previous = _this.state.searchTerm.current;
    }

    return _this;
  }

  _createClass(SearchBar, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      return /*#__PURE__*/React.createElement(Downshift, {
        ref: this.downshift,
        itemToString: function itemToString(item) {
          return item && item.label;
        }
      }, function (downshiftProps) {
        var isOpen = downshiftProps.isOpen,
            openMenu = downshiftProps.openMenu,
            closeMenu = downshiftProps.closeMenu,
            getInputProps = downshiftProps.getInputProps;
        return /*#__PURE__*/React.createElement("div", {
          style: {
            width: "100%"
          }
        }, /*#__PURE__*/React.createElement(Hotkeys, {
          zIndex: 10,
          keys: {
            // @ts-ignore
            esc: function esc() {
              return document.activeElement.blur();
            },
            "/": _this2.handleOpenHotkey
          }
        }), /*#__PURE__*/React.createElement(Hotkeys, {
          zIndex: 11,
          disabled: !isOpen,
          keys: {
            esc: function esc() {
              _this2.cancelSearchTerm();

              closeMenu();
            },
            enter: function enter() {
              return setTimeout(function () {
                var selectedItem = _this2.downshift.current.state.selectedItem;

                if (selectedItem) {
                  closeMenu();

                  _this2.submitSearchTerm(selectedItem);
                }
              });
            }
          }
        }), /*#__PURE__*/React.createElement(Elevation, {
          className: classnames(searchWrapper, {
            active: _this2.state.active
          }),
          z: 0
        }, /*#__PURE__*/React.createElement(SearchBarWrapper, null, /*#__PURE__*/React.createElement(SearchBarInputWrapper, null, /*#__PURE__*/React.createElement(Icon, {
          className: icon,
          icon: /*#__PURE__*/React.createElement(SearchIcon, null)
        }), /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("input", getInputProps({
          placeholder: "Search...",
          className: classnames("mdc-text-field__input", searchBarInput),
          ref: _this2.input,
          value: _this2.state.searchTerm.current,
          // @ts-ignore
          onClick: openMenu,
          onBlur: function onBlur() {
            _this2.cancelSearchTerm();

            _this2.setState({
              active: false
            });
          },
          onFocus: function onFocus() {
            _this2.setState({
              active: true
            });

            openMenu();
          },
          onChange: function onChange(e) {
            var value = e.target.value || "";

            _this2.setState(function (state) {
              state.searchTerm.current = value;
              return state;
            });
          }
        }))), /*#__PURE__*/React.createElement(SearchShortcut, null, "/"))), isOpen && /*#__PURE__*/React.createElement(SearchBarDropdown, {
          context: _this2
        })));
      });
    }
  }]);

  return SearchBar;
}(React.Component);

var SearchBarContainer = function SearchBarContainer() {
  var routerProps = useRouter();
  return /*#__PURE__*/React.createElement(SearchBar, routerProps);
};

export default SearchBarContainer;
//# sourceMappingURL=SearchBar.js.map