"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(require("react"));
var dialog_1 = require("./dialog");
var base_1 = require("@rmwc/base");
var textfield_1 = require("@rmwc/textfield");
/** A snackbar queue for rendering messages */
var DialogQueue = /** @class */ (function (_super) {
    __extends(DialogQueue, _super);
    function DialogQueue(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            closingDialogs: {}
        };
        _this.forceUpdate = _this.forceUpdate.bind(_this);
        _this.props.dialogs.on('change', _this.forceUpdate);
        return _this;
    }
    DialogQueue.prototype.componentWillUnmount = function () {
        this.props.dialogs.off('change', this.forceUpdate);
    };
    DialogQueue.prototype.removeDialog = function (evt, dialog) {
        var _a;
        var _this = this;
        this.setState({
            closingDialogs: __assign({}, this.state.closingDialogs, (_a = {}, _a[dialog.id] = true, _a))
        }, function () {
            dialog.resolve(evt);
            setTimeout(function () {
                var index = _this.props.dialogs.array.indexOf(dialog);
                !!~index && _this.props.dialogs.array.splice(index, 1);
                var closingDialogs = _this.state.closingDialogs;
                delete closingDialogs[dialog.id];
                _this.setState({
                    closingDialogs: closingDialogs
                });
            }, 150);
        });
    };
    DialogQueue.prototype.render = function () {
        var _this = this;
        var _a = this.props, dialogs = _a.dialogs, defaultDialogProps = __rest(_a, ["dialogs"]);
        // A simple way to show only one at a time
        // We loop through until we find a dialog thats not closing
        // When one is closing, we flip this flag and render all of the other ones in a closed state
        // This ensures we get the proper animations for closing dialogs
        var foundOpen = false;
        return dialogs.array.map(function (dialog) {
            var resolve = dialog.resolve, reject = dialog.reject, id = dialog.id, inputProps = dialog.inputProps, rest = __rest(dialog, ["resolve", "reject", "id", "inputProps"]);
            var rendered = (React.createElement(dialog_1.SimpleDialog, __assign({}, defaultDialogProps, rest, { key: id, open: !_this.state.closingDialogs[id] && !foundOpen, onClose: function (evt) {
                    _this.removeDialog(evt, dialog);
                    dialog.onClose && dialog.onClose(evt);
                } })));
            if (!_this.state.closingDialogs[id]) {
                foundOpen = true;
            }
            return rendered;
        });
    };
    DialogQueue.displayName = 'DialogQueue';
    return DialogQueue;
}(React.Component));
exports.DialogQueue = DialogQueue;
/**
 * A base dialog factory that handle setting up the promise
 * With some consistent behavior
 */
var dialogFactory = function (factory, queue) { return function (dialog) {
    return new Promise(function (resolve, reject) {
        var d = factory(__assign({ id: base_1.randomId() }, dialog, { resolve: resolve, reject: reject }));
        queue.push(d);
    });
}; };
/**
 * Handle prompt dialogs
 * We have to jump through a few hoops to get the value back out
 */
var PromptBody = /** @class */ (function (_super) {
    __extends(PromptBody, _super);
    function PromptBody() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            value: ''
        };
        return _this;
    }
    PromptBody.prototype.componentDidMount = function () {
        var _this = this;
        this.props.apiRef(function () { return _this.state.value; });
    };
    PromptBody.prototype.render = function () {
        var _this = this;
        return (React.createElement("div", null,
            !!this.props.body && (React.createElement("div", { style: { marginBottom: '1rem' } }, this.props.body)),
            React.createElement(textfield_1.TextField, __assign({ style: { width: '100%' }, autoFocus: true }, this.props.inputProps, { value: this.state.value, onChange: function (evt) { return _this.setState({ value: evt.currentTarget.value }); } }))));
    };
    PromptBody.displayName = 'PromptBody';
    return PromptBody;
}(React.Component));
var promptFactory = function (dialog) {
    var getValue = function () { return ''; };
    var body = (React.createElement(PromptBody, { body: dialog.body, inputProps: dialog.inputProps, apiRef: function (_getValue) { return (getValue = _getValue); } }));
    return __assign({ title: 'Prompt' }, dialog, { body: body, resolve: function (evt) {
            dialog.resolve(evt.detail.action === 'accept' ? getValue() : null);
            getValue = undefined;
        } });
};
/** Alerts */
var alertFactory = function (dialog) { return (__assign({ title: 'Alert', body: 'You have been alerted!', acceptLabel: 'OK', cancelLabel: null }, dialog, { resolve: function (evt) { return dialog.resolve(evt.detail.action); } })); };
/** Confirm */
var confirmFactory = function (dialog) { return (__assign({ title: 'Confirm', body: 'Are you sure you want do that?', acceptLabel: 'OK', cancelLabel: 'Cancel' }, dialog, { resolve: function (evt) {
        return dialog.resolve(evt.detail.action === 'accept');
    } })); };
/** Creates a snackbar queue */
exports.createDialogQueue = function () {
    var dialogs = new base_1.ArrayEmitter();
    return {
        dialogs: dialogs,
        alert: dialogFactory(alertFactory, dialogs),
        confirm: dialogFactory(confirmFactory, dialogs),
        prompt: dialogFactory(promptFactory, dialogs)
    };
};
